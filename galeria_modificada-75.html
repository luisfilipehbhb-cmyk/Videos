<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Galeria</title>
<link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=DM+Sans:wght@300;400;500&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
  :root {
    --bg: #0a0a0c;
    --surface: #111114;
    --surface2: #1a1a1f;
    --border: #2a2a33;
    --accent: #e8ff47;
    --accent2: #ff6b35;
    --text: #f0f0f5;
    --muted: #5a5a6e;
    --arrow-color: #e8ff47;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* HEADER */
  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 28px 40px;
    border-bottom: 1px solid var(--border);
    position: sticky;
    top: 0;
    background: rgba(10,10,12,0.92);
    backdrop-filter: blur(20px);
    z-index: 100;
  }

  .logo {
    font-family: 'Syne', sans-serif;
    font-weight: 800;
    font-size: 22px;
    letter-spacing: -0.5px;
    color: var(--text);
  }

  .logo span {
    color: var(--accent);
  }

  .import-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    background: var(--accent);
    color: #0a0a0c;
    border: none;
    padding: 12px 24px;
    border-radius: 8px;
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 0.3px;
  }

  .import-btn:hover {
    background: #fff;
    transform: translateY(-1px);
    box-shadow: 0 8px 30px rgba(232,255,71,0.25);
  }

  .import-btn svg { width: 18px; height: 18px; }

  .header-actions { display: flex; align-items: center; gap: 10px; }

  .outline-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    background: transparent;
    color: var(--text);
    border: 1px solid var(--border);
    padding: 11px 18px;
    border-radius: 8px;
    font-family: 'Syne', sans-serif;
    font-weight: 600;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }
  .outline-btn:hover { border-color: var(--accent); color: var(--accent); }
  .outline-btn svg { width: 16px; height: 16px; }

  #fileInput, #jsonInput { display: none; }

  .toast {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%) translateY(20px);
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 12px 22px;
    border-radius: 10px;
    font-family: 'Syne', sans-serif;
    font-size: 13px;
    font-weight: 600;
    opacity: 0;
    pointer-events: none;
    transition: all 0.3s;
    z-index: 9999;
  }
  .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
  .toast.success { border-color: var(--accent); color: var(--accent); }
  .toast.error { border-color: #ff4444; color: #ff4444; }

  /* GALLERY GRID */
  .gallery-container {
    padding: 40px;
  }

  .gallery-title {
    font-family: 'Syne', sans-serif;
    font-size: 13px;
    font-weight: 600;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 24px;
  }

  .gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: 16px;
  }

  .gallery-item {
    position: relative;
    aspect-ratio: 16/10;
    border-radius: 10px;
    overflow: hidden;
    cursor: pointer;
    background: var(--surface);
    border: 1px solid var(--border);
    transition: all 0.3s;
    group: true;
  }

  .gallery-item:hover {
    border-color: var(--accent);
    transform: translateY(-3px);
    box-shadow: 0 16px 40px rgba(0,0,0,0.5);
  }

  .gallery-item img,
  .gallery-item video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }

  .gallery-item .overlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 60%);
    opacity: 0;
    transition: 0.3s;
    display: flex;
    align-items: flex-end;
    padding: 14px;
  }

  .gallery-item:hover .overlay { opacity: 1; }

  .gallery-item .file-name {
    font-size: 12px;
    font-weight: 500;
    color: #fff;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .gallery-item .annotation-badge {
    position: absolute;
    top: 10px;
    right: 10px;
    background: var(--accent);
    color: #000;
    border-radius: 20px;
    padding: 3px 10px;
    font-size: 11px;
    font-weight: 700;
    font-family: 'Syne', sans-serif;
    display: none;
  }

  .gallery-item .type-badge {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    border-radius: 4px;
    padding: 3px 8px;
    font-size: 11px;
    font-weight: 600;
    color: var(--muted);
  }

  .empty-state {
    grid-column: 1 / -1;
    text-align: center;
    padding: 100px 40px;
    color: var(--muted);
  }

  .empty-state .icon {
    font-size: 60px;
    margin-bottom: 20px;
    opacity: 0.3;
  }

  .empty-state h3 {
    font-family: 'Syne', sans-serif;
    font-size: 20px;
    margin-bottom: 8px;
    color: var(--text);
    opacity: 0.5;
  }

  .empty-state p {
    font-size: 14px;
    opacity: 0.6;
  }

  /* MODAL / FULLSCREEN */
  .modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.97);
    z-index: 1000;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .modal.active { display: flex; }

  .modal-close {
    position: absolute;
    top: 24px;
    right: 24px;
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    width: 44px;
    height: 44px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 20px;
    transition: all 0.2s;
    z-index: 10;
  }

  .modal-close:hover {
    background: var(--accent);
    color: #000;
    border-color: var(--accent);
  }

  .media-wrapper {
    position: relative;
    max-width: 90vw;
    max-height: 85vh;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .media-wrapper img {
    max-width: 90vw;
    max-height: 85vh;
    object-fit: contain;
    border-radius: 8px;
  }

  .video-container {
    position: relative;
    display: inline-block;
    text-align: center;
  }

  .video-container video {
    max-width: 90vw;
    max-height: 78vh;
    display: block;
    border-radius: 8px;
  }

  .video-area {
    position: relative;
    display: inline-block;
    line-height: 0;
    /* overflow hidden removed - handled by video element itself */
  }

  .video-area * {
    line-height: normal;
  }

  /* PLAYLIST DE TEXTOS */
  #textPlaylistWrapper {
    display: none;
    position: fixed;
    top: 60px;
    right: 0;
    width: 140px;
    height: 50vh;
    min-width: 60px;
    min-height: 80px;
    z-index: 500;
    flex-direction: column;
    background: rgba(255,255,255,0.06);
    border-left: 1px solid rgba(255,255,255,0.10);
    border-bottom: 1px solid rgba(255,255,255,0.10);
  }
  #textPlaylistWrapper.visible {
    display: flex;
  }
  #textPlaylist {
    width: 100%;
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 12px 8px 8px;
    pointer-events: all;
    scrollbar-width: none;
  }
  #textPlaylist::-webkit-scrollbar { display: none; }
  #textPlaylistEmpty {
    text-align: center;
    color: rgba(255,255,255,0.2);
    font-family: 'Syne', sans-serif;
    font-size: 11px;
    padding: 20px 8px;
    pointer-events: none;
    line-height: 1.6;
  }
  .playlist-item {
    position: relative;
    flex-shrink: 0;
    border-radius: 6px;
    overflow: visible;
  }
  /* FLIP CARD */
  .playlist-card-scene {
    perspective: 600px;
    width: 100%;
    position: relative;
  }
  .playlist-card {
    position: relative;
    width: 100%;
    transform-style: preserve-3d;
    transition: transform 0.45s cubic-bezier(0.4,0.2,0.2,1);
    cursor: pointer;
  }
  .playlist-card.flipped {
    transform: rotateY(180deg);
  }
  .playlist-card-face {
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    border-radius: 6px;
    width: 100%;
    box-sizing: border-box;
  }
  .playlist-card-face img,
  .subcard-face img {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    pointer-events: none;
  }
  /* Frente: fluxo normal (define altura do card) */
  .playlist-card-front {
    position: relative;
  }
  /* Verso: absolute mas reserva espa√ßo com visibility:hidden clone */
  .playlist-card-back {
    position: absolute;
    top: 0; left: 0; right: 0;
    transform: rotateY(180deg);
    background: #1a1a1a;
    border: 2px solid #e8ff47;
    display: flex;
    flex-direction: column;
    min-height: 100%;
  }
  /* Spacer invis√≠vel que for√ßa o card a ter altura suficiente para o verso */
  .playlist-card-back-spacer {
    visibility: hidden;
    pointer-events: none;
    padding: 8px 10px;
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 13px;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    min-height: 44px;
  }
  .playlist-card-back textarea {
    flex: 1;
    background: transparent;
    border: none;
    color: #e8ff47;
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 13px;
    padding: 8px;
    resize: none;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    line-height: 1.4;
  }
  .playlist-card-back-actions {
    display: flex;
    gap: 4px;
    padding: 4px 6px 6px;
  }
  .playlist-card-back-save {
    flex: 1;
    background: #e8ff47;
    color: #0a0a0c;
    border: none;
    border-radius: 4px;
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 11px;
    padding: 5px;
    cursor: pointer;
  }
  .playlist-card-back-cancel {
    background: rgba(255,255,255,0.1);
    color: #fff;
    border: none;
    border-radius: 4px;
    font-family: 'Syne', sans-serif;
    font-size: 11px;
    padding: 5px 8px;
    cursor: pointer;
  }

  /* ‚îÄ‚îÄ SUB-CARDS (lista dentro do verso) ‚îÄ‚îÄ */
  .subcard-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 6px 8px 4px;
  }
  .subcard-scene + .subcard-add-btn {
    margin-top: 16px;
  }
  .subcard-scene {
    perspective: 500px;
    position: relative;
  }
  .subcard {
    position: relative;
    width: 100%;
    transform-style: preserve-3d;
    transition: transform 0.4s cubic-bezier(0.4,0.2,0.2,1);
    cursor: pointer;
    min-height: 34px;
  }
  .subcard.flipped { transform: rotateY(180deg); }
  .subcard-face {
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    border-radius: 5px;
    width: 100%;
    box-sizing: border-box;
    padding: 6px 28px 6px 8px;
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 12px;
    white-space: pre-wrap;
    overflow-wrap: break-word;
    min-height: 34px;
    display: flex;
    align-items: center;
  }
  .subcard-front {
    background: rgba(232,255,71,0.15);
    border: 1px solid rgba(232,255,71,0.35);
    color: #e8ff47;
    position: relative;
  }
  .subcard-back {
    position: absolute;
    inset: 0;
    transform: rotateY(180deg);
    background: rgba(255,107,53,0.15);
    border: 1px solid rgba(255,107,53,0.45);
    color: #ff6b35;
  }
  .subcard-remove {
    position: absolute;
    top: 50%;
    right: 4px;
    transform: translateY(-50%);
    width: 18px; height: 18px;
    background: transparent;
    border: none;
    color: rgba(255,255,255,0.3);
    font-size: 14px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    z-index: 5;
    pointer-events: all;
    border-radius: 50%;
    line-height: 1;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }
  .subcard-remove:hover { color: #ef4444; background: rgba(239,68,68,0.15); }
  .subcard-add-btn {
    width: 100%;
    background: rgba(232,255,71,0.07);
    border: 1px dashed rgba(232,255,71,0.3);
    color: rgba(232,255,71,0.6);
    border-radius: 5px;
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 13px;
    padding: 5px;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 0.5px;
    margin-top: 4px;
  }
  .subcard-add-btn:hover {
    background: rgba(232,255,71,0.15);
    border-color: rgba(232,255,71,0.6);
    color: #e8ff47;
  }
  .playlist-item-remove {
    position: absolute;
    top: -7px; right: -7px;
    width: 18px; height: 18px;
    background: #ef4444;
    border: none;
    border-radius: 50%;
    color: #fff;
    font-size: 11px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    line-height: 1;
    pointer-events: all;
  }
  #textPlaylistResizeHandle {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 28px;
    height: 28px;
    cursor: nesw-resize;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 20;
    pointer-events: all;
    color: rgba(255,255,255,0.35);
    font-size: 14px;
    user-select: none;
  }
  #textPlaylistResizeHandle:hover {
    color: rgba(255,255,255,0.7);
  }

  .image-container {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .image-area {
    position: relative;
    display: inline-block;
    line-height: 0;
  }

  .image-area * { line-height: normal; }

  .image-area img {
    max-width: 90vw;
    max-height: 62vh;
    object-fit: contain;
    border-radius: 8px;
    display: block;
  }

  /* SLIDESHOW */
  .slideshow-exit-btn {
    display: none;
    margin-top: 12px;
    padding: 12px 28px;
    background: #ef4444;
    color: #fff;
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 14px;
    border-radius: 8px;
    cursor: pointer;
    border: none;
    letter-spacing: 0.5px;
  }

  .img-fade { animation: imgFadeIn 0.4s ease; }
  @keyframes imgFadeIn { from { opacity: 0; } to { opacity: 1; } }

  /* NAV BUTTONS */
  .img-nav-btn {
    position: fixed;
    top: 50%;
    transform: translateY(-50%);
    z-index: 1100;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.15);
    color: var(--text);
    width: 52px;
    height: 52px;
    border-radius: 50%;
    font-size: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    backdrop-filter: blur(8px);
    transition: background 0.2s, transform 0.15s;
    user-select: none;
  }
  .img-nav-btn:hover { background: rgba(232,255,71,0.18); border-color: var(--accent); }
  .img-nav-btn:active { transform: translateY(-50%) scale(0.92); }
  #imgNavPrev { left: 12px; }
  #imgNavNext { right: 12px; }

  /* ARROW OVERLAY */
  .arrow-overlay {
    position: absolute;
    inset: 0;
    pointer-events: none;
    border-radius: 8px;
    overflow: visible;
  }

  .annotation-arrow {
    position: absolute;
    pointer-events: all;
    cursor: move;
    user-select: none;
    display: none;
    filter: drop-shadow(0 2px 8px rgba(0,0,0,0.8));
    transition: filter 0.2s;
    outline: 2px dashed rgba(255,255,255,0.85);
    outline-offset: 6px;
    border-radius: 4px;
  }

  .annotation-arrow:hover {
    filter: drop-shadow(0 4px 16px rgba(232,255,71,0.6));
  }

  .annotation-arrow svg {
    width: 72px;
    height: 72px;
  }

  /* VIDEO TOOLBAR */
  .video-toolbar {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-top: 16px;
    padding: 12px 20px;
    background: var(--surface);
    border-radius: 12px;
    border: 1px solid var(--border);
  }

  .toolbar-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 18px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: var(--surface2);
    color: var(--text);
    font-family: 'Syne', sans-serif;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
  }

  .toolbar-btn:hover {
    border-color: var(--accent);
    color: var(--accent);
  }

  .toolbar-btn.active {
    background: var(--accent);
    color: #000;
    border-color: var(--accent);
  }

  .toolbar-btn.done-btn {
    background: var(--accent2);
    color: #fff;
    border-color: var(--accent2);
  }

  .toolbar-btn.done-btn:hover {
    background: #ff8a5c;
    border-color: #ff8a5c;
    color: #fff;
  }

  .toolbar-btn svg { width: 18px; height: 18px; }

  .separator {
    width: 1px;
    height: 30px;
    background: var(--border);
  }

  .timestamp-display {
    font-family: 'Syne', sans-serif;
    font-size: 13px;
    color: var(--muted);
    min-width: 80px;
  }

  /* ANNOTATIONS LIST */
  .annotations-panel {
    display: none;
    position: absolute;
    right: -260px;
    top: 0;
    width: 240px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 16px;
    max-height: 400px;
    overflow-y: auto;
  }

  .annotations-panel.visible { display: block; }

  .annotations-panel h4 {
    font-family: 'Syne', sans-serif;
    font-size: 12px;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 12px;
  }

  .ann-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 12px;
    background: var(--surface2);
    border-radius: 6px;
    margin-bottom: 6px;
    font-size: 13px;
    cursor: pointer;
    border: 1px solid transparent;
    transition: 0.2s;
  }

  .ann-item:hover {
    border-color: var(--accent);
    color: var(--accent);
  }

  .ann-item .ann-time {
    font-family: 'Syne', sans-serif;
    font-weight: 600;
    color: var(--accent);
  }

  .ann-item .ann-delete {
    background: none;
    border: none;
    color: var(--muted);
    cursor: pointer;
    font-size: 16px;
    padding: 0 4px;
    transition: 0.2s;
  }

  .ann-item .ann-delete:hover { color: #ff4444; }

  /* FLASH INDICATOR */
  .arrow-mode-hint {
    position: absolute;
    top: 14px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--accent);
    color: #000;
    font-family: 'Syne', sans-serif;
    font-size: 12px;
    font-weight: 700;
    padding: 6px 16px;
    border-radius: 20px;
    display: none;
    z-index: 10;
    white-space: nowrap;
    animation: pulse 1.5s infinite;
  }

  /* TEXT INPUT POPUP */
  .text-popup {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 2000;
    align-items: center;
    justify-content: center;
  }
  .text-popup.active { display: flex; }
  .text-popup-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 24px;
    width: 320px;
    display: flex;
    flex-direction: column;
    gap: 14px;
  }
  .text-popup-box h3 {
    font-family: 'Syne', sans-serif;
    font-size: 15px;
    font-weight: 700;
    color: var(--text);
  }
  .text-popup-box textarea {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    font-size: 14px;
    padding: 12px;
    resize: none;
    height: 90px;
    outline: none;
    transition: border-color 0.2s;
  }
  .text-popup-box textarea:focus { border-color: var(--accent); }
  .text-popup-actions { display: flex; gap: 10px; }
  .text-popup-actions button {
    flex: 1;
    padding: 11px;
    border-radius: 8px;
    border: 1px solid var(--border);
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
  }
  .text-popup-confirm {
    background: var(--accent);
    color: #000;
    border-color: var(--accent) !important;
  }
  .text-popup-cancel {
    background: transparent;
    color: var(--muted);
  }
  .text-popup-cancel:hover { border-color: #ff4444 !important; color: #ff4444; }

  .video-container video.recording::--webkit-media-controls { opacity: 0.15 !important; }
  .video-container.recording-mode video::-webkit-media-controls { opacity: 0.15 !important; }
  .video-container.recording-mode video::-webkit-media-controls-panel { opacity: 0.15 !important; }

  /* ROTATE HANDLE */
  .rotate-handle {
    position: absolute;
    bottom: -18px;
    right: -18px;
    width: 22px;
    height: 22px;
    background: #fff;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: grab;
    touch-action: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.5);
    z-index: 10;
    pointer-events: all;
  }
  .rotate-handle:active { cursor: grabbing; }
  .rotate-handle svg { width: 13px; height: 13px; color: #0a0a0c; }

  /* SCROLLBAR */
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  /* ‚îÄ‚îÄ MOBILE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  @media (max-width: 600px) {
    header {
      padding: 14px 16px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .header-actions {
      width: 100%;
      flex-wrap: wrap;
      gap: 8px;
    }

    .outline-btn {
      flex: 1;
      justify-content: center;
      padding: 10px 10px;
      font-size: 12px;
    }

    .outline-btn svg { display: none; }

    .import-btn {
      width: 100%;
      justify-content: center;
      padding: 12px;
      font-size: 14px;
    }

    .gallery-container { padding: 16px; }

    .gallery-grid {
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
    }

    /* Modal fullscreen on mobile */
    .modal {
      padding: 0;
      justify-content: flex-start;
    }

    .modal-close {
      top: 12px;
      right: 12px;
      width: 36px;
      height: 36px;
      font-size: 16px;
    }

    .media-wrapper {
      width: 100vw;
      max-width: 100vw;
      max-height: 100vh;
      flex-direction: column;
      justify-content: flex-start;
      padding-top: 56px;
    }

    .media-wrapper img {
      max-width: 100vw;
      max-height: 55vh;
    }

    .video-container {
      width: 100vw;
    }

    .video-container video {
      max-width: 100vw;
      max-height: 55vh;
      border-radius: 0;
    }

    .image-container { width: 100vw; }
    .image-area img {
      max-width: 100vw;
      max-height: 52vh;
      border-radius: 0;
    }

    .video-toolbar {
      width: 100vw;
      border-radius: 0;
      border-left: none;
      border-right: none;
      margin-top: 0;
      padding: 10px 12px;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .toolbar-btn {
      padding: 9px 12px;
      font-size: 12px;
      gap: 5px;
    }

    .toolbar-btn svg { width: 15px; height: 15px; }

    .timestamp-display { font-size: 12px; min-width: 60px; }

    .separator { display: none; }

    /* Annotations panel on mobile: slide up from bottom */
    .annotations-panel {
      position: fixed;
      right: 0;
      left: 0;
      bottom: 0;
      top: auto;
      width: 100%;
      border-radius: 16px 16px 0 0;
      max-height: 50vh;
      z-index: 200;
    }
  }

</style>
</head>
<body>

<header>
  <div class="logo">Frame<span>.</span></div>
  <div class="header-actions">
    <button class="outline-btn" onclick="downloadBackup()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="7,10 12,15 17,10"/>
        <line x1="12" y1="15" x2="12" y2="3"/>
      </svg>
      Backup ZIP
    </button>
    <button class="outline-btn" onclick="document.getElementById('jsonInput').click()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="17,8 12,3 7,8"/>
        <line x1="12" y1="3" x2="12" y2="15"/>
      </svg>
      Restaurar ZIP
    </button>
    <button class="import-btn" onclick="document.getElementById('fileInput').click()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
        <path d="M12 5v14M5 12l7-7 7 7"/>
      </svg>
      Importar m√≠dia
    </button>
  </div>
  <input type="file" id="subcardImgInput" accept="image/*" style="display:none">
  <input type="file" id="fileInput" multiple accept="image/*,video/*" onchange="importFiles(event)">
  <input type="file" id="jsonInput" accept=".zip" onchange="restoreBackup(event)">
</header>

<div class="gallery-container">
  <div class="gallery-title">Sua Galeria</div>
  <div class="gallery-grid" id="galleryGrid">
    <div class="empty-state">
      <div class="icon">üé¨</div>
      <h3>Galeria vazia</h3>
      <p>Importe fotos e v√≠deos para come√ßar</p>
    </div>
  </div>
</div>

<!-- FULLSCREEN MODAL -->
<div class="modal" id="modal">
  <button class="modal-close" onclick="closeModal()">‚úï</button>
  <button class="img-nav-btn" id="imgNavPrev" onclick="imgNavigate(-1)" style="display:none">‚è™</button>
  <button class="img-nav-btn" id="imgNavNext" onclick="imgNavigate(1)" style="display:none">‚è©</button>

  <div class="media-wrapper" id="mediaWrapper">
    <!-- Image viewer -->
    <div class="image-container" id="imageContainer" style="display:none">
      <div class="image-area" id="imageArea">
        <img id="modalImage" src="" alt="">
        <!-- arrowOverlay is moved here dynamically in image mode -->
      </div>
      <div class="video-toolbar" id="imageToolbar" style="flex-wrap:wrap;gap:6px;">
        <button class="toolbar-btn" id="imgUndoBtn" onclick="imgUndoAnnotation()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9,14 4,9 9,4"/><path d="M20 20v-7a4 4 0 0 0-4-4H4"/></svg>
          Desfazer
        </button>
        <div class="separator"></div>
        <button class="toolbar-btn" id="imgArrowBtn" onclick="imgActivateArrow()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/><polyline points="9,5 19,5 19,15"/></svg>
          Inserir Seta
        </button>
        <button class="toolbar-btn" id="imgTextBtn" onclick="imgActivateText()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4,7 4,4 20,4 20,7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>
          Inserir Texto
        </button>
        <button class="toolbar-btn done-btn" id="imgDoneBtn" onclick="imgSaveCurrent()" style="display:none">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20,6 9,17 4,12"/></svg>
          Conclu√≠do
        </button>
        <button class="toolbar-btn" id="imgFontMinusBtn" onclick="imgChangeFontSize(-2)" style="display:none;min-width:36px;">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="16" height="16"><line x1="5" y1="12" x2="19" y2="12"/></svg>A
        </button>
        <span id="imgFontSizeDisplay" style="display:none;font-family:'Syne',sans-serif;font-size:12px;color:var(--muted);min-width:34px;text-align:center;">10px</span>
        <button class="toolbar-btn" id="imgFontPlusBtn" onclick="imgChangeFontSize(2)" style="display:none;min-width:36px;">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="16" height="16"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>A
        </button>
        <button class="toolbar-btn" id="imgBgColorBtn" onclick="cycleTextBgColor()" style="display:none;min-width:44px;font-size:16px;" title="Cor de fundo do texto">
          <span id="imgBgColorDot" style="display:inline-block;width:14px;height:14px;border-radius:3px;background:#e8ff47;border:1px solid rgba(255,255,255,0.3);vertical-align:middle;margin-right:4px;"></span>Cor
        </button>
        <button class="toolbar-btn" id="imgEditTextBtn" onclick="imgReopenTextEdit()" style="opacity:0.35;cursor:not-allowed;">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
          Editar
        </button>
        <div class="separator"></div>
        <button class="toolbar-btn" onclick="document.getElementById('imgUploadFileInput').click()" style="color:var(--accent);border-color:var(--accent);">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16,16 12,12 8,16"/><line x1="12" y1="12" x2="12" y2="21"/><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"/></svg>
          Upload de imagens
        </button>
        <button class="toolbar-btn" id="imgPlayBtn" onclick="startSlideshow()" style="color:#4ade80;border-color:#4ade80;">
          <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><polygon points="5,3 19,12 5,21"/></svg>
          Play
        </button>
        <div class="separator"></div>
        <button class="toolbar-btn" id="imgOpacityBtn" onclick="toggleImgOpacity()" title="Tornar foto opaca/vis√≠vel">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
          Opacidade
        </button>
      </div>
      <input type="file" id="imgUploadFileInput" multiple accept="image/*" style="display:none" onchange="importFiles(event)">
      <button class="slideshow-exit-btn" id="slideshowExitBtn" onclick="stopSlideshow()">‚úï Sair do Slideshow</button>
    </div>

    <!-- Video viewer -->
    <div class="video-container" id="videoContainer" style="display:none">
      <div class="video-area" id="videoArea">
        <video id="modalVideo" style="cursor:pointer;display:block;" onclick="handleVideoClick()"></video>

      <div class="arrow-overlay" id="arrowOverlay">
        <div class="arrow-mode-hint" id="arrowHint">üèπ Arraste a seta para posicionar</div>

        <!-- Draggable arrow -->
        <div class="annotation-arrow" id="annotationArrow">
          <svg viewBox="0 0 80 80" fill="none">
            <defs>
              <filter id="glow">
                <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <g filter="url(#glow)">
              <line x1="14" y1="66" x2="56" y2="24" stroke="#e8ff47" stroke-width="5" stroke-linecap="round"/>
              <polygon points="56,24 38,26 54,42" fill="#e8ff47"/>
              <circle cx="14" cy="66" r="5" fill="#e8ff47" opacity="0.6"/>
            </g>
          </svg>
          <div class="rotate-handle" id="arrowRotateHandle">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
              <path d="M21.5 2v6h-6"/><path d="M21.34 15.57a10 10 0 1 1-.57-8.38"/>
            </svg>
          </div>
        </div>

        <!-- Draggable photo -->
        <div id="annotationPhotoEl" style="
          display:none;
          position:absolute;
          cursor:move;
          user-select:none;
          pointer-events:all;
          width:200px;
          height:300px;
          outline: 2px dashed rgba(255,255,255,0.85);
          outline-offset: 4px;
          z-index: 30;
          border-radius:6px;
          overflow:hidden;
          box-shadow:0 4px 20px rgba(0,0,0,0.6);
        ">
          <img id="annotationPhotoImg" src="" style="width:100%;height:100%;object-fit:cover;pointer-events:none;display:block;">
          <div id="photoResizeHandle" style="
            position:absolute;bottom:-11px;right:-11px;
            width:28px;height:28px;
            background:#fff;border-radius:50%;
            display:flex;align-items:center;justify-content:center;
            cursor:nwse-resize;pointer-events:all;
            box-shadow:0 2px 8px rgba(0,0,0,0.5);
            z-index:10;touch-action:none;
          ">
            <svg viewBox="0 0 24 24" fill="none" stroke="#0a0a0c" stroke-width="2.5" width="13" height="13">
              <polyline points="15,3 21,3 21,9"/><polyline points="9,21 3,21 3,15"/>
              <line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/>
            </svg>
          </div>
        </div>

        <!-- Draggable text label -->
        <div id="annotationTextEl" style="
          display:none;
          position:absolute;
          cursor:move;
          user-select:none;
          pointer-events:all;
          background:rgba(232,255,71,0.92);
          color:#0a0a0c;
          font-family:'Syne',sans-serif;
          font-weight:700;
          font-size:15px;
          padding:6px 14px 6px 14px;
          border-radius:6px;
          box-shadow:0 4px 20px rgba(0,0,0,0.6);
          overflow-wrap:break-word;
          white-space:pre-wrap;
          outline: 2px dashed rgba(255,255,255,0.85);
          outline-offset: 4px;
          z-index: 30;
        ">Texto aqui<button id="inlineEditTextBtn" onclick="event.stopPropagation();reopenTextEdit()" title="Editar texto" style="
            position:absolute;
            top:-12px;
            right:-12px;
            width:26px;
            height:26px;
            border-radius:50%;
            background:#0a0a0c;
            border:2px solid rgba(255,255,255,0.5);
            color:#fff;
            display:flex;
            align-items:center;
            justify-content:center;
            cursor:pointer;
            pointer-events:all;
            box-shadow:0 2px 8px rgba(0,0,0,0.6);
            z-index:20;
            padding:0;
          ">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="13" height="13">
              <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
              <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
          </button><div id="textResizeHandle" style="
            position:absolute;bottom:-11px;right:-11px;
            width:22px;height:22px;
            background:#fff;border-radius:50%;
            display:flex;align-items:center;justify-content:center;
            cursor:nwse-resize;pointer-events:all;
            box-shadow:0 2px 8px rgba(0,0,0,0.5);
            z-index:10;touch-action:none;
          ">
            <svg viewBox="0 0 24 24" fill="none" stroke="#0a0a0c" stroke-width="2.5" width="11" height="11">
              <polyline points="15,3 21,3 21,9"/><polyline points="9,21 3,21 3,15"/>
              <line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/>
            </svg>
          </div><div class="rotate-handle" style="
            position:absolute;
            top:-24px;
            left:50%;
            transform:translateX(-50%);
            width:20px;
            height:20px;
            background:rgba(255,255,255,0.9);
            border-radius:50%;
            display:flex;
            align-items:center;
            justify-content:center;
            cursor:grab;
            touch-action:none;
            box-shadow:0 2px 8px rgba(0,0,0,0.5);
            z-index:10;
            pointer-events:all;
          ">
            <svg viewBox="0 0 24 24" fill="none" stroke="#0a0a0c" stroke-width="2.5" width="12" height="12">
              <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
            </svg>
          </div></div>

        <!-- Checkmark overlay - appears during marked time range -->
        <div id="checkmarkOverlay" style="
          display:none;
          position:absolute;
          inset:0;
          pointer-events:none;
          z-index:22;
          align-items:center;
          justify-content:center;
          flex-direction:column;
          gap:12px;
        ">
          <div id="checkmarkEmoji" style="font-size:min(40vw,40vh);line-height:1;user-select:none;">‚úÖ</div>
          <div id="checkmarkProgress" style="width:min(35vw,35vh);height:6px;background:rgba(255,255,255,0.2);border-radius:3px;overflow:hidden;">
            <div id="checkmarkProgressFill" style="height:100%;width:0%;background:rgba(255,255,255,0.7);border-radius:3px;transition:width 0.1s linear;"></div>
          </div>
        </div>

        <!-- X overlay - appears during marked time range -->
        <div id="xmarkOverlay" style="
          display:none;
          position:absolute;
          inset:0;
          pointer-events:none;
          z-index:22;
          align-items:center;
          justify-content:center;
          flex-direction:column;
          gap:12px;
        ">
          <div id="xmarkEmoji" style="font-size:min(40vw,40vh);line-height:1;user-select:none;">‚ùå</div>
          <div id="xmarkProgress" style="width:min(35vw,35vh);height:6px;background:rgba(255,255,255,0.2);border-radius:3px;overflow:hidden;">
            <div id="xmarkProgressFill" style="height:100%;width:0%;background:rgba(255,255,255,0.7);border-radius:3px;transition:width 0.1s linear;"></div>
          </div>
        </div>

        <!-- Static emoji overlays shown immediately on pause (disappear on play) -->
        <div id="staticCheckOverlay" style="display:none;position:absolute;inset:0;pointer-events:none;z-index:23;align-items:center;justify-content:center;">
          <div style="font-size:min(40vw,40vh);line-height:1;user-select:none;opacity:0.25;">‚úÖ</div>
        </div>
        <div id="staticXOverlay" style="display:none;position:absolute;inset:0;pointer-events:none;z-index:23;align-items:center;justify-content:center;">
          <div style="font-size:min(40vw,40vh);line-height:1;user-select:none;opacity:0.25;">‚ùå</div>
        </div>
        <!-- Black flash between annotation pauses -->
        <div id="blackFlash" style="
          display:none;
          position:absolute;inset:0;
          background:#000;
          z-index:30;
          pointer-events:none;
        "></div>
        <div id="savedArrowsContainer" style="position:absolute;inset:0;pointer-events:none;z-index:20;"></div>

        <!-- Stopwatch: resets on pause/timestamp, counts up on play -->
        <div id="stopwatch" style="
          position:absolute;bottom:10px;right:10px;z-index:25;
          font-family:'Syne',monospace;font-size:22px;font-weight:700;
          color:rgba(255,255,255,0.9);text-shadow:0 1px 6px rgba(0,0,0,0.9);
          pointer-events:none;letter-spacing:1px;display:none;
        ">0.000</div>

        <!-- Subtle play hint during screen record pause -->
        <!-- Skip block video overlay - blacks out only the video during skip -->
        <div id="skipVideoBlack" style="
          display:none;
          position:absolute;
          inset:0;
          background:#000;
          z-index:35;
          pointer-events:none;
          border-radius:8px;
        "></div>

      </div><!-- end video-area -->

      <!-- Story navigation buttons -->
      <button id="storyPrev" onclick="storyNavigate(-1)" style="
        display:none;
        position:absolute;
        left:-52px;
        top:50%;
        transform:translateY(-50%);
        width:44px;height:44px;
        border-radius:50%;
        background:rgba(255,255,255,0.1);
        border:1px solid rgba(255,255,255,0.2);
        color:#fff;
        font-size:20px;
        cursor:pointer;
        z-index:50;
        align-items:center;
        justify-content:center;
        backdrop-filter:blur(4px);
        transition:background 0.2s;
      ">‚Äπ</button>
      <button id="storyNext" onclick="storyNavigate(1)" style="
        display:none;
        position:absolute;
        right:-52px;
        top:50%;
        transform:translateY(-50%);
        width:44px;height:44px;
        border-radius:50%;
        background:rgba(255,255,255,0.1);
        border:1px solid rgba(255,255,255,0.2);
        color:#fff;
        font-size:20px;
        cursor:pointer;
        z-index:50;
        align-items:center;
        justify-content:center;
        backdrop-filter:blur(4px);
        transition:background 0.2s;
      ">‚Ä∫</button>

      <!-- Custom progress bar -->
      <div id="customProgressBar" style="
        width:88%;
        margin:0 auto;
        padding:10px 0 4px;
        display:flex;
        flex-direction:column;
        gap:6px;
        user-select:none;
      ">
        <div style="display:flex;justify-content:space-between;align-items:center;padding:0 2px;">
          <span id="progressCurrent" style="font-family:'Syne',sans-serif;font-size:12px;color:var(--muted);">00:00</span>
          <span id="progressDuration" style="font-family:'Syne',sans-serif;font-size:12px;color:var(--muted);">00:00</span>
        </div>
        <div id="progressTrack" style="
          position:relative;
          width:100%;
          height:20px;
          background:rgba(255,255,255,0.15);
          border-radius:6px;
          cursor:pointer;
          touch-action:none;
        ">
          <!-- Skip zone markers -->
          <div id="skipZonesContainer" style="position:absolute;inset:0;border-radius:6px;overflow:hidden;pointer-events:none;z-index:1;"></div>

          <!-- Left dark mask (before trimStart) -->
          <div id="trimMaskLeft" style="
            position:absolute;top:0;left:0;height:100%;width:0%;
            background:rgba(0,0,0,0.55);
            border-radius:6px 0 0 6px;
            pointer-events:none;z-index:2;
          "></div>

          <!-- Active range highlight -->
          <div id="trimRangeBar" style="
            position:absolute;top:0;height:100%;left:0%;width:100%;
            background:rgba(255,255,255,0.82);
            pointer-events:none;z-index:2;
          "></div>

          <!-- Right dark mask (after trimEnd) -->
          <div id="trimMaskRight" style="
            position:absolute;top:0;right:0;height:100%;width:0%;
            background:rgba(0,0,0,0.55);
            border-radius:0 6px 6px 0;
            pointer-events:none;z-index:2;
          "></div>

          <!-- Playback fill (inside active range) -->
          <div id="progressFill" style="
            position:absolute;top:0;left:0%;height:100%;width:0%;
            background:rgba(255,255,255,0.38);
            pointer-events:none;z-index:3;
          "></div>

          <!-- Playhead thumb -->
          <div id="progressThumb" style="
            position:absolute;
            top:50%;left:0%;
            transform:translate(-50%,-50%);
            width:16px;height:16px;
            background:#fff;
            border-radius:50%;
            pointer-events:none;
            box-shadow:0 0 6px rgba(0,0,0,0.6);
            z-index:6;
          "></div>

          <!-- Trim Start handle -->
          <div id="trimHandleStart" style="
            position:absolute;
            top:50%;left:0%;
            transform:translate(-50%,-50%);
            width:14px;height:28px;
            background:var(--accent);
            border-radius:4px;
            cursor:ew-resize;
            z-index:7;
            touch-action:none;
            box-shadow:0 2px 8px rgba(0,0,0,0.7);
            display:flex;align-items:center;justify-content:center;gap:2px;
          ">
            <div style="width:2px;height:12px;background:rgba(0,0,0,0.4);border-radius:1px;"></div>
            <div style="width:2px;height:12px;background:rgba(0,0,0,0.4);border-radius:1px;"></div>
          </div>

          <!-- Trim End handle -->
          <div id="trimHandleEnd" style="
            position:absolute;
            top:50%;left:100%;
            transform:translate(-50%,-50%);
            width:14px;height:28px;
            background:#f87171;
            border-radius:4px;
            cursor:ew-resize;
            z-index:7;
            touch-action:none;
            box-shadow:0 2px 8px rgba(0,0,0,0.7);
            display:flex;align-items:center;justify-content:center;gap:2px;
          ">
            <div style="width:2px;height:12px;background:rgba(0,0,0,0.4);border-radius:1px;"></div>
            <div style="width:2px;height:12px;background:rgba(0,0,0,0.4);border-radius:1px;"></div>
          </div>

          <!-- Time tooltip for handles -->
          <div id="trimTooltip" style="
            display:none;
            position:absolute;
            top:-28px;
            transform:translateX(-50%);
            background:rgba(0,0,0,0.85);
            color:#fff;
            font-family:'Syne',sans-serif;
            font-size:11px;font-weight:700;
            padding:3px 8px;border-radius:4px;
            pointer-events:none;z-index:20;
            white-space:nowrap;
          "></div>
        </div>
      </div>

      <div id="videoToolbar" class="video-toolbar">
        <span class="timestamp-display" id="timestampDisplay">00:00:00</span>
        <div class="separator"></div>
        <div class="separator"></div>
        <button class="toolbar-btn" id="arrowBtn" onclick="activateArrowMode()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="5" y1="19" x2="19" y2="5"/>
            <polyline points="9,5 19,5 19,15"/>
          </svg>
          Inserir Seta
        </button>
        <button class="toolbar-btn" id="textBtn" onclick="activateTextMode()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="4,7 4,4 20,4 20,7"/>
            <line x1="9" y1="20" x2="15" y2="20"/>
            <line x1="12" y1="4" x2="12" y2="20"/>
          </svg>
          Inserir Texto
        </button>
        <button class="toolbar-btn" id="photoBtn" onclick="document.getElementById('photoInsertInput').click()" title="Inserir foto no v√≠deo">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/>
            <polyline points="21,15 16,10 5,21"/>
          </svg>
          Inserir Foto
        </button>
        <input type="file" id="photoInsertInput" accept="image/*" style="display:none" onchange="activatePhotoMode(event)">
        <button class="toolbar-btn done-btn" id="doneBtn" onclick="saveCurrent()" style="display:none">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
            <polyline points="20,6 9,17 4,12"/>
          </svg>
          Conclu√≠do
        </button>
        <button class="toolbar-btn" id="fontMinusBtn" onclick="changeFontSize(-2)" style="display:none;min-width:36px;">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="16" height="16"><line x1="5" y1="12" x2="19" y2="12"/></svg>
          A
        </button>
        <span id="fontSizeDisplay" style="display:none;font-family:'Syne',sans-serif;font-size:12px;color:var(--muted);min-width:34px;text-align:center;">10px</span>
        <button class="toolbar-btn" id="fontPlusBtn" onclick="changeFontSize(2)" style="display:none;min-width:36px;">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="16" height="16"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
          A
        </button>
        <button class="toolbar-btn" id="bgColorBtn" onclick="cycleTextBgColor()" style="display:none;min-width:44px;font-size:16px;" title="Cor de fundo do texto">
          <span id="bgColorDot" style="display:inline-block;width:14px;height:14px;border-radius:3px;background:#e8ff47;border:1px solid rgba(255,255,255,0.3);vertical-align:middle;margin-right:4px;"></span>Cor
        </button>
        <button class="toolbar-btn" id="editTextBtn" onclick="reopenTextEdit()" title="Editar texto da anota√ß√£o" style="opacity:0.35;cursor:not-allowed;">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
          </svg>
          Editar
        </button>
        <button class="toolbar-btn" id="addToPlaylistBtn" onclick="addTextToPlaylist()" title="Adicionar texto atual √† playlist de rolagem" style="font-size:18px;">
          üì¶
        </button>
        <div class="separator"></div>
        <button class="toolbar-btn" id="muteBtn" onclick="toggleMute()" title="Mutar/desmutar v√≠deo" style="font-size:18px;">
          üîä
        </button>
        <button class="toolbar-btn" id="speedBtn" onclick="toggleSpeed()" title="Alternar velocidade 0.5x / normal" style="font-family:'Syne',sans-serif;font-weight:700;font-size:13px;letter-spacing:0.5px;">
          0.5x
        </button>
        <button class="toolbar-btn" onclick="rewindToTrimStart()" title="Voltar ao in√≠cio do trim (A)">‚èÆÔ∏è</button>
        <button class="toolbar-btn" onclick="trimABackToCurrent()" title="Mover Trim A para o momento atual">Trim A üîô</button>
        <button class="toolbar-btn" onclick="trimBBackToCurrent()" title="Mover Trim B para o momento atual">Trim B üîô</button>
        <button class="toolbar-btn" id="loopBtn" onclick="toggleTrimLoop()" title="Loop do Trim atual" style="font-size:18px;">üîÅ</button>
        <button class="toolbar-btn" id="recordBtn" onclick="toggleScreenRecord()" style="border-color:#f87171;color:#f87171;">
          <svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18">
            <circle cx="12" cy="12" r="8"/>
          </svg>
          Gravar Tela
        </button>
        <button class="toolbar-btn" onclick="copyCurrentFileName()" title="Copiar nome do arquivo">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
            <rect x="9" y="9" width="13" height="13" rx="2"/>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
          </svg>
          Copiar
        </button>



        <div class="separator"></div>
      </div>
    </div>

    <!-- Annotations side panel -->
    <div class="annotations-panel" id="annotationsPanel"></div>
  </div>

  <!-- Screen record exit button (outside video, below toolbar) -->
  <div id="recordExitBtn" style="
    display:none;
    margin-top:12px;
    padding:12px 28px;
    background:#ef4444;
    color:#fff;
    font-family:'Syne',sans-serif;
    font-weight:700;
    font-size:14px;
    border-radius:8px;
    cursor:pointer;
    border:none;
    letter-spacing:0.5px;
    text-align:center;
    width:100%;
    max-width:200px;
  " onclick="stopScreenRecord()">‚úï Sair da Grava√ß√£o</div>

  <!-- Playlist de textos (barra lateral rol√°vel) -->
  <div id="textPlaylistWrapper">
    <div id="textPlaylist"></div>
    <div id="textPlaylistEmpty">üì¶<br>Clique em üì¶<br>para adicionar<br>textos aqui</div>
    <div id="textPlaylistResizeHandle" title="Redimensionar">‚§°</div>
  </div>

</div>

<script>
// ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let mediaItems = [];            // { id, name, type, url }
let annotations = {};           // { mediaId: [ { time, xPct, yPct } ] }
let pendingAnnotations = [];    // from backup, waiting for matching media to be imported
let currentMediaId = null;
let isImageMode = false;
let arrowMode = false;
let textMode = false;
let pendingTime = null;
let activeMode = null;
let lastAddedTime = null; // timestamp of last saved annotation (for highlight)
let lastSavedAnnId = null; // id of most recently saved annotation (for undo)
let _annCounter = 0; // monotonic counter for unique annotation IDs
function _newAnnId() { return '_ann_' + (++_annCounter) + '_' + Date.now(); }
let emojiRedoStack = []; // stack for redo of emoji/skip annotations
let isDragging = false;
let selectedAnnIndex = null; // index of text annotation currently selected
let dragOffsetX = 0, dragOffsetY = 0;
let arrowXPct = 50, arrowYPct = 50;
let textXPct = 50, textYPct = 40;
let arrowRotation = 0, textRotation = 0;
let textFontSize = 10;
const TEXT_BG_COLORS = [
  { label: 'Amarelo', value: 'rgba(232,255,71,0.92)', dot: '#e8ff47' },
  { label: 'Branco',  value: 'rgba(255,255,255,0.92)', dot: '#ffffff' },
  { label: 'Verde',   value: 'rgba(34,197,94,0.92)',   dot: '#22c55e' },
  { label: 'Vermelho',value: 'rgba(239,68,68,0.92)',   dot: '#ef4444' },
];
let textBgColorIdx = 0;
function cycleTextBgColor() {
  textBgColorIdx = (textBgColorIdx + 1) % TEXT_BG_COLORS.length;
  const c = TEXT_BG_COLORS[textBgColorIdx];
  const imgDot = document.getElementById('imgBgColorDot');
  const vidDot = document.getElementById('bgColorDot');
  if (imgDot) imgDot.style.background = c.dot;
  if (vidDot) vidDot.style.background = c.dot;
  // Update live preview on the active text element
  const textLive = document.getElementById('annotationTextEl');
  if (textLive && textLive.style.display !== 'none') {
    textLive.style.background = c.value;
  }
}
let pendingTextContent = '';
let isRotating = false;
let rotateTarget = null;
let rotateCenterX = 0, rotateCenterY = 0;
let rotateStartAngle = 0, rotateStartRot = 0;
// Slideshow
let slideshowMode = false;
let slideshowTimer = null;
// Line highlight
let nextHighlightLine = 0;

const video = document.getElementById('modalVideo');
const arrowEl = document.getElementById('annotationArrow');
const textEl = document.getElementById('annotationTextEl');
const arrowHint = document.getElementById('arrowHint');
const arrowBtn = document.getElementById('arrowBtn');
const textBtn = document.getElementById('textBtn');
const doneBtn = document.getElementById('doneBtn');
const overlay = document.getElementById('arrowOverlay');
const tsDisplay = document.getElementById('timestampDisplay');
const savedArrowsContainer = document.getElementById('savedArrowsContainer');

// ‚îÄ‚îÄ‚îÄ IMPORT FILES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function importFiles(e) {
  const files = Array.from(e.target.files);
  let appliedCount = 0;

  files.forEach(file => {
    const url = URL.createObjectURL(file);
    const id = Date.now() + '_' + Math.random().toString(36).substr(2,8);
    const type = file.type.startsWith('video') ? 'video' : 'image';
    const item = { id, name: file.name, type, url };
    mediaItems.push(item);
    annotations[id] = [];

    // Check if backup has pending annotations for this file
    const normalize = name => name.toLowerCase().replace(/\.[^/.]+$/, '').trim();
    const pending = pendingAnnotations.find(p =>
      p.name === file.name ||
      normalize(p.name) === normalize(file.name)
    );
    if (pending) {
      annotations[id] = pending.annotations;
      pendingAnnotations = pendingAnnotations.filter(p => p !== pending);
      appliedCount++;
    }

    addGalleryCard(item);
    updateBadge(id);
  });

  if (appliedCount > 0) {
    showToast(`‚úì Setas do backup aplicadas em ${appliedCount} arquivo(s)!`, 'success');
  }

  document.getElementById('fileInput').value = '';
}

function addGalleryCard(item) {
  const grid = document.getElementById('galleryGrid');
  // Remove empty state
  const empty = grid.querySelector('.empty-state');
  if (empty) empty.remove();

  const div = document.createElement('div');
  div.className = 'gallery-item';
  div.id = 'card_' + item.id;
  div.onclick = () => openModal(item.id);

  const badge = document.createElement('span');
  badge.className = 'annotation-badge';
  badge.id = 'badge_' + item.id;
  badge.textContent = '‚óè Seta';

  const typeBadge = document.createElement('span');
  typeBadge.className = 'type-badge';
  typeBadge.textContent = item.type === 'video' ? '‚ñ∂ V√≠deo' : 'üñº Foto';

  if (item.type === 'video') {
    const v = document.createElement('video');
    v.src = item.url;
    v.muted = true;
    v.preload = 'metadata';
    div.appendChild(v);
  } else {
    const img = document.createElement('img');
    img.src = item.url;
    div.appendChild(img);
  }

  const overlay = document.createElement('div');
  overlay.className = 'overlay';
  const name = document.createElement('span');
  name.className = 'file-name';
  name.textContent = item.name;
  overlay.appendChild(name);

  div.appendChild(overlay);
  div.appendChild(typeBadge);
  div.appendChild(badge);
  grid.appendChild(div);
}

// ‚îÄ‚îÄ‚îÄ MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function openModal(id) {
  const item = mediaItems.find(m => m.id === id);
  if (!item) return;
  currentMediaId = id;

  const modal = document.getElementById('modal');
  modal.classList.add('active');
  renderTextPlaylist();

  const imageContainer = document.getElementById('imageContainer');
  const vidContainer = document.getElementById('videoContainer');
  const arrowOverlayEl = document.getElementById('arrowOverlay');

  // Set mode BEFORE resetArrowState so it resets the right buttons
  isImageMode = item.type === 'image';
  resetArrowState();

  if (item.type === 'image') {
    // Move shared overlay into imageArea
    document.getElementById('imageArea').appendChild(arrowOverlayEl);
    document.getElementById('modalImage').src = item.url;
    // Restore opacity state
    const faded = !!item.faded;
    const imgEl2 = document.getElementById('modalImage'); imgEl2.style.filter = faded ? 'brightness(0.35)' : ''; imgEl2.dataset.faded = faded ? '1' : '';
    document.getElementById('imgOpacityBtn').style.color = faded ? 'var(--accent)' : '';
    document.getElementById('imgOpacityBtn').style.borderColor = faded ? 'var(--accent)' : '';
    imageContainer.style.display = 'flex';
    vidContainer.style.display = 'none';
    renderSavedArrows();
    // Show nav buttons only if multiple images exist
    const imgCount = mediaItems.filter(m => m.type === 'image').length;
    document.getElementById('imgNavPrev').style.display = imgCount > 1 ? 'flex' : 'none';
    document.getElementById('imgNavNext').style.display = imgCount > 1 ? 'flex' : 'none';
  } else {
    // Ensure overlay is back in videoArea
    const videoArea = document.getElementById('videoArea');
    if (!videoArea.contains(arrowOverlayEl)) videoArea.appendChild(arrowOverlayEl);
    imageContainer.style.display = 'none';
    vidContainer.style.display = 'block';
    document.getElementById('imgNavPrev').style.display = 'none';
    document.getElementById('imgNavNext').style.display = 'none';
    // Reset trim
    trimStart = 0;
    trimEnd = Infinity;
    const trimBtn = document.getElementById('trimBtn');
    if (trimBtn) { trimBtn.style.color = ''; trimBtn.style.borderColor = ''; }
    const trimEndBtn = document.getElementById('trimEndBtn');
    if (trimEndBtn) { trimEndBtn.style.color = ''; trimEndBtn.style.borderColor = ''; }
    // updateTrimVisuals() will be called after loadedmetadata
    // Reset checkmark pending state
    checkmarkPending = false;
    checkmarkStart = null;
    const checkBtn = document.getElementById('checkBtn');
    if (checkBtn) { checkBtn.style.color = ''; checkBtn.style.borderColor = ''; checkBtn.style.background = ''; }
    const checkOverlay = document.getElementById('checkmarkOverlay');
    if (checkOverlay) checkOverlay.style.display = 'none';
    // Reset xmark pending state
    xmarkPending = false;
    xmarkStart = null;
    const xmarkBtn = document.getElementById('xmarkBtn');
    if (xmarkBtn) { xmarkBtn.style.color = ''; xmarkBtn.style.borderColor = ''; xmarkBtn.style.background = ''; }
    const xmarkOverlay = document.getElementById('xmarkOverlay');
    if (xmarkOverlay) xmarkOverlay.style.display = 'none';
    video.src = item.url;
    video.currentTime = 0;
    const sw = document.getElementById('stopwatch');
    if (sw) sw.style.display = 'block';
    swReset();
    const playWhenReady = () => {
      video.removeEventListener('canplay', playWhenReady);
      video.play().catch(() => {});
    };
    video.addEventListener('canplay', playWhenReady);
    video.load();
    renderSavedArrows(0);
    renderAnnotationsList();
  }
}

function closeModal() {
  if (screenRecordMode) stopScreenRecord();
  if (slideshowMode) stopSlideshow();

  // Move overlay back to videoArea if it was in image mode
  if (isImageMode) {
    const videoArea = document.getElementById('videoArea');
    const arrowOverlayEl = document.getElementById('arrowOverlay');
    if (!videoArea.contains(arrowOverlayEl)) videoArea.appendChild(arrowOverlayEl);
  }
  document.getElementById('imgNavPrev').style.display = 'none';
  document.getElementById('imgNavNext').style.display = 'none';
  isImageMode = false;

  video.pause();
  swStop(); swReset();
  const sw = document.getElementById('stopwatch');
  if (sw) sw.style.display = 'none';
  video.src = '';
  document.getElementById('modal').classList.remove('active');
  document.getElementById('imageContainer').style.display = 'none';
  document.getElementById('videoContainer').style.display = 'none';
  document.getElementById('annotationsPanel').classList.remove('visible');
  document.getElementById('textPlaylistWrapper').classList.remove('visible');
  resetArrowState();
  currentMediaId = null;
}

// ‚îÄ‚îÄ‚îÄ ARROW MODE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function activateArrowMode() {
  if (arrowMode) {
    showToast('Conclua ou desfa√ßa a seta antes de inserir outra.', 'error');
    return;
  }
  if (textMode) {
    showToast('Conclua ou desfa√ßa o texto antes de inserir uma seta.', 'error');
    return;
  }
  cancelAll();
  arrowMode = true;
  activeMode = 'arrow';
  pendingTime = isImageMode ? 0 : safeAnnotationTime(video.currentTime);
  if (!isImageMode) video.pause();
  arrowXPct = 50; arrowYPct = 50;
  placeArrow(arrowXPct, arrowYPct);
  arrowEl.style.display = 'block';
  arrowHint.style.display = 'block';
  arrowBtn.classList.add('active');
  doneBtn.style.display = 'flex';
}

// ‚îÄ‚îÄ‚îÄ TEXT MODE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function activateTextMode() {
  if (textMode) {
    showToast('Conclua ou desfa√ßa o texto antes de inserir outro.', 'error');
    return;
  }
  if (arrowMode) {
    showToast('Conclua ou desfa√ßa a seta antes de inserir um texto.', 'error');
    return;
  }
  cancelAll();
  pendingTime = isImageMode ? 0 : safeAnnotationTime(video.currentTime);
  if (!isImageMode) video.pause();
  document.getElementById('textPopupInput').value = '';
  document.getElementById('textPopup').classList.add('active');
  setTimeout(() => document.getElementById('textPopupInput').focus(), 100);
}

function confirmTextInput() {
  const val = document.getElementById('textPopupInput').value.trim();
  if (!val) return;
  document.getElementById('textPopup').classList.remove('active');
  pendingTextContent = val;
  textMode = true;
  activeMode = 'text';
  textXPct = 50; textYPct = 40;
  // Set text directly in the div (first child node before the handles)
  textEl.childNodes[0].textContent = val;
  textEl.style.fontSize = textFontSize + 'px';
  // Remove any width/height from previous text to start fresh
  textEl.style.width = '';
  textEl.style.height = '';
  textEl.style.display = 'block';
  textEl.style.background = TEXT_BG_COLORS[textBgColorIdx].value;
  placeText(textXPct, textYPct);
  textBtn.classList.add('active');
  doneBtn.style.display = 'flex';
  document.getElementById('fontMinusBtn').style.display = 'flex'; document.getElementById('fontSizeDisplay').style.display = 'inline-block'; document.getElementById('fontSizeDisplay').textContent = textFontSize + 'px';
  document.getElementById('fontPlusBtn').style.display = 'flex';
  { const _b=document.getElementById('bgColorBtn'); const _d=document.getElementById('bgColorDot'); if(_b)_b.style.display='flex'; if(_d)_d.style.background=TEXT_BG_COLORS[textBgColorIdx].dot; }
  document.getElementById('editTextBtn').style.opacity = '1'; document.getElementById('editTextBtn').style.cursor = 'pointer';
  
}

function cancelTextMode() {
  document.getElementById('textPopup').classList.remove('active');
  // Clear any pending edit state
  window._editingAnnIndex = null;
  window._editingEditTime = null;
  pendingTime = null;
  pendingTextContent = '';
}

function cancelAll() {
  arrowMode = false;
  textMode = false;
  photoMode = false;
  activeMode = null;
  pendingTime = null;
  pendingTextContent = '';
  pendingPhotoDataUrl = null;
  arrowRotation = 0;
  textRotation = 0;
  textFontSize = 10;
  textEl.style.fontSize = '15px';
  arrowEl.style.display = 'none';
  textEl.style.display = 'none';
  const _pEl = document.getElementById('annotationPhotoEl');
  if (_pEl) _pEl.style.display = 'none';
  arrowHint.style.display = 'none';
  if (!isImageMode) {
    arrowBtn.classList.remove('active');
    textBtn.classList.remove('active');
    const _pb = document.getElementById('photoBtn');
    if (_pb) _pb.classList.remove('active');
    doneBtn.style.display = 'none';
    
    document.getElementById('fontMinusBtn').style.display = 'none'; document.getElementById('fontSizeDisplay').style.display = 'none';
    document.getElementById('fontPlusBtn').style.display = 'none';
  { const _b=document.getElementById('bgColorBtn'); if(_b)_b.style.display='none'; }
    document.getElementById('editTextBtn').style.opacity = '0.35';
    document.getElementById('editTextBtn').style.cursor = 'not-allowed';
  }
}

// ‚îÄ‚îÄ‚îÄ SAVE (UNIFIED) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function saveCurrent() {
  if (activeMode === 'arrow') saveArrowAnnotation();
  else if (activeMode === 'text') saveTextAnnotation();
  else if (activeMode === 'photo') savePhotoAnnotation();
}

function saveArrowAnnotation() {
  if (pendingTime === null || !currentMediaId) return;
  const savedTime = pendingTime;
  
  // Check if this is a "move existing arrow" operation
  if (window._movingArrowIndex !== undefined && window._movingArrowIndex !== null) {
    const origMoves = window._movingArrowOrigMoves || [{ time: savedTime, xPct: arrowXPct, yPct: arrowYPct, rotation: arrowRotation }];
    const moveTime = window._movingArrowTime || safeAnnotationTime(video.currentTime);
    window._movingArrowIndex = null;
    window._movingArrowTime = null;
    window._movingArrowOrigMoves = null;
    // Add new move entry
    const updatedMoves = [...origMoves, { time: moveTime, xPct: arrowXPct, yPct: arrowYPct, rotation: arrowRotation }];
    updatedMoves.sort((a, b) => a.time - b.time);
    annotations[currentMediaId].push({ kind: 'arrow', time: savedTime, xPct: origMoves[0].xPct, yPct: origMoves[0].yPct, rotation: origMoves[0].rotation || 0,
      moves: updatedMoves, _id: _newAnnId() });
    dismissedTimes.add(moveTime);
  } else {
    // Fresh arrow insertion
    annotations[currentMediaId].push({ kind: 'arrow', time: savedTime, xPct: arrowXPct, yPct: arrowYPct, rotation: arrowRotation,
      moves: [{ time: savedTime, xPct: arrowXPct, yPct: arrowYPct, rotation: arrowRotation }],
        _id: _newAnnId()
      });
    dismissedTimes.add(savedTime);
  }
  lastSavedAnnId = annotations[currentMediaId][annotations[currentMediaId].length - 1]._id;
  annotations[currentMediaId].sort((a,b) => a.time - b.time);
  cancelAll();
  renderSavedArrows();
  renderAnnotationsList();
  updateBadge(currentMediaId);
}

function saveTextAnnotation() {
  if (!pendingTextContent || !currentMediaId) return;
  const savedTime = pendingTime;
  // Vai direto pro üì¶ move sem aparecer no v√≠deo
  if (!textPlaylists[currentMediaId]) textPlaylists[currentMediaId] = [];
  textPlaylists[currentMediaId].push({
    kind: 'text',
    text: pendingTextContent,
    fontSize: textFontSize,
    bgColor: TEXT_BG_COLORS[textBgColorIdx].value,
    backText: '',
    customWidth: null,
    customHeight: null,
    time: savedTime,
    savedTrimStart: trimStart,
    savedTrimEnd: isFinite(trimEnd) ? trimEnd : null,
    subCards: [],
    _flipped: false
  });
  cancelAll();
  buildPauseQueue();
  _playlistScrollToBottom = true;
  renderTextPlaylist();
  showToast('üì¶ Texto adicionado ao move', 'success');
}

// ‚îÄ‚îÄ‚îÄ SAFE ANNOTATION TIME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// If a new annotation lands within 270ms of an existing one, push it forward.
function safeAnnotationTime(rawTime) {
  const GAP = 0.27; // 270ms
  const anns = annotations[currentMediaId] || [];
  // Collect all existing trigger times
  const usedTimes = [];
  for (const a of anns) {
    if (a.kind === 'checkmark' || a.kind === 'xmark') {
      usedTimes.push(a.timeStart, a.timeEnd);
    } else if (a.kind !== 'line_highlight') {
      usedTimes.push(a.time);
    }
  }
  // Never place at t=0 ‚Äî the video start causes timing issues with the RAF loop
  let t = Math.max(rawTime, 0.05);
  let changed = true;
  while (changed) {
    changed = false;
    for (const u of usedTimes) {
      if (Math.abs(t - u) < GAP) {
        t = u + GAP;
        changed = true;
      }
    }
  }
  return t;
}

function updateBadge(id) {
  const badge = document.getElementById('badge_' + id);
  if (!badge) return;
  const count = annotations[id] ? annotations[id].length : 0;
  if (count > 0) {
    badge.style.display = 'block';
    badge.textContent = count === 1 ? '‚óè Seta' : `‚óè ${count} Setas`;
  } else {
    badge.style.display = 'none';
  }
  // Rebuild pause queue whenever annotations change for the active video
  if (id === currentMediaId && video.readyState >= 1) {
    buildPauseQueue();
    advancePauseQueueTo(video.currentTime);
  }
}

// ‚îÄ‚îÄ‚îÄ DRAG ARROW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
arrowEl.addEventListener('mousedown', e => startDrag(e, 'arrow'));
arrowEl.addEventListener('touchstart', e => startDragTouch(e, 'arrow'), { passive: false });
textEl.addEventListener('mousedown', e => startDrag(e, 'text'));
textEl.addEventListener('touchstart', e => startDragTouch(e, 'text'), { passive: false });

let dragTarget = null;
let dragStartX = 0, dragStartY = 0;     // mouse position at drag start
let dragStartXPct = 0, dragStartYPct = 0; // element center % at drag start
let dragStartElLeft = 0, dragStartElTop = 0; // element px position at drag start (for text)

function startDrag(e, target) {
  if (!arrowMode && !textMode) return;
  e.preventDefault();
  isDragging = true;
  dragTarget = target;
  const overlayRect = overlay.getBoundingClientRect();
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  dragStartXPct = target === 'arrow' ? arrowXPct : textXPct;
  dragStartYPct = target === 'arrow' ? arrowYPct : textYPct;
  // Capture actual px position from element's current screen position
  if (target === 'text') {
    const elRect = textEl.getBoundingClientRect();
    dragStartElLeft = elRect.left - overlayRect.left;
    dragStartElTop = elRect.top - overlayRect.top;
  }
  window._dragOverlayW = overlayRect.width;
  window._dragOverlayH = overlayRect.height;
}

function startDragTouch(e, target) {
  if (!arrowMode && !textMode) return;
  e.preventDefault();
  isDragging = true;
  dragTarget = target;
  const touch = e.touches[0];
  const overlayRect = overlay.getBoundingClientRect();
  dragStartX = touch.clientX;
  dragStartY = touch.clientY;
  dragStartXPct = target === 'arrow' ? arrowXPct : textXPct;
  dragStartYPct = target === 'arrow' ? arrowYPct : textYPct;
  // Capture actual px position from element's current screen position
  if (target === 'text') {
    const elRect = textEl.getBoundingClientRect();
    dragStartElLeft = elRect.left - overlayRect.left;
    dragStartElTop = elRect.top - overlayRect.top;
  }
  window._dragOverlayW = overlayRect.width;
  window._dragOverlayH = overlayRect.height;
}

document.addEventListener('mousemove', doDrag);
document.addEventListener('touchmove', doDragTouch, { passive: false });

function doDrag(e) {
  if (!isDragging) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  const w = window._dragOverlayW || overlay.getBoundingClientRect().width;
  const h = window._dragOverlayH || overlay.getBoundingClientRect().height;
  if (dragTarget === 'arrow') {
    const newX = Math.max(0, Math.min(100, dragStartXPct + (dx / w) * 100));
    const newY = Math.max(0, Math.min(100, dragStartYPct + (dy / h) * 100));
    arrowXPct = newX; arrowYPct = newY;
    placeArrow(arrowXPct, arrowYPct);
  } else {
    // Text: move in px directly, no clamping
    const newLeft = dragStartElLeft + dx;
    const newTop = dragStartElTop + dy;
    const elW = textEl.offsetWidth || 100;
    const elH = textEl.offsetHeight || 40;
    textEl.style.left = newLeft + 'px';
    textEl.style.top = newTop + 'px';
    textXPct = ((newLeft + elW / 2) / w) * 100;
    textYPct = ((newTop + elH / 2) / h) * 100;
  }
}

function doDragTouch(e) {
  if (!isDragging) return;
  e.preventDefault();
  const touch = e.touches[0];
  const dx = touch.clientX - dragStartX;
  const dy = touch.clientY - dragStartY;
  const w = window._dragOverlayW || overlay.getBoundingClientRect().width;
  const h = window._dragOverlayH || overlay.getBoundingClientRect().height;
  if (dragTarget === 'arrow') {
    const newX = Math.max(0, Math.min(100, dragStartXPct + (dx / w) * 100));
    const newY = Math.max(0, Math.min(100, dragStartYPct + (dy / h) * 100));
    arrowXPct = newX; arrowYPct = newY;
    placeArrow(arrowXPct, arrowYPct);
  } else {
    // Text: move in px directly, no clamping
    const newLeft = dragStartElLeft + dx;
    const newTop = dragStartElTop + dy;
    const elW = textEl.offsetWidth || 100;
    const elH = textEl.offsetHeight || 40;
    textEl.style.left = newLeft + 'px';
    textEl.style.top = newTop + 'px';
    textXPct = ((newLeft + elW / 2) / w) * 100;
    textYPct = ((newTop + elH / 2) / h) * 100;
  }
}

document.addEventListener('mouseup', () => { isDragging = false; isRotating = false; });
document.addEventListener('touchend', () => { isDragging = false; isRotating = false; });

// ‚îÄ‚îÄ‚îÄ FONT SIZE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function changeFontSize(delta) {
  textFontSize = Math.max(4, Math.min(48, textFontSize + delta));
  textEl.style.fontSize = textFontSize + 'px';
  const disp = document.getElementById('fontSizeDisplay');
  if (disp) disp.textContent = textFontSize + 'px';
}

// ‚îÄ‚îÄ‚îÄ REOPEN TEXT EDIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function reopenTextEdit() {
  // Se h√° um item da playlist selecionado, editar ele
  if (window._editingPlaylistIdx != null) {
    const idx = window._editingPlaylistIdx;
    const item = (textPlaylists[currentMediaId] || [])[idx];
    if (item && item.kind !== 'photo') {
      const popup = document.getElementById('textPopup');
      const input = document.getElementById('textPopupInput');
      input.value = item.text || '';
      // Guardar callback de confirma√ß√£o tempor√°ria
      window._playlistEditConfirmOverride = (newText) => {
        textPlaylists[currentMediaId][idx].text = newText;
        window._editingPlaylistIdx = null;
        window._playlistEditConfirmOverride = null;
        const editBtn = document.getElementById('editTextBtn');
        if (editBtn) { editBtn.style.opacity = '0.35'; editBtn.style.cursor = 'not-allowed'; }
        renderTextPlaylist();
      };
      popup.classList.add('active');
      setTimeout(() => input.focus(), 100);
      return;
    }
  }
  if (!textMode) {
    showToast('Nenhum texto ativo para editar. Insira um texto primeiro.', 'error');
    return;
  }
  const popup = document.getElementById('textPopup');
  const input = document.getElementById('textPopupInput');
  const currentText = pendingTextContent || (textEl.childNodes[0] && textEl.childNodes[0].textContent) || '';
  input.value = currentText;
  popup.classList.add('active');
  setTimeout(() => input.focus(), 100);
}

// ‚îÄ‚îÄ‚îÄ FREE RESIZE HANDLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let isResizing = false;
let resizeStartX = 0, resizeStartY = 0;
let resizeStartW = 0, resizeStartH = 0;

document.getElementById('textResizeHandle').addEventListener('mousedown', startFreeResize);

// Prevent drag when clicking the inline edit button
document.getElementById('inlineEditTextBtn').addEventListener('mousedown', e => e.stopPropagation());
document.getElementById('inlineEditTextBtn').addEventListener('touchstart', e => e.stopPropagation(), { passive: false });
document.getElementById('textResizeHandle').addEventListener('touchstart', startFreeResize, { passive: false });

function startFreeResize(e) {
  e.stopPropagation();
  e.preventDefault();
  isResizing = true;
  const client = e.touches ? e.touches[0] : e;
  resizeStartX = client.clientX;
  resizeStartY = client.clientY;
  resizeStartW = textEl.offsetWidth;
  resizeStartH = textEl.offsetHeight;
}

document.addEventListener('mousemove', e => {
  if (!isResizing) return;
  applyResize(e.clientX, e.clientY);
});
document.addEventListener('touchmove', e => {
  if (!isResizing) return;
  applyResize(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: true });
document.addEventListener('mouseup', () => { isResizing = false; });
document.addEventListener('touchend', () => { isResizing = false; });

function applyResize(cx, cy) {
  const dx = cx - resizeStartX; // right = wider, left = narrower
  const dy = cy - resizeStartY; // down = taller, up = shorter
  const newW = Math.max(60, resizeStartW + dx);
  const newH = Math.max(30, resizeStartH + dy);
  textEl.style.width = newW + 'px';
  textEl.style.maxWidth = 'none';
  textEl.style.height = newH + 'px';
  textEl.style.whiteSpace = 'pre-wrap';
  textEl.style.wordBreak = 'break-word';
}

// Override confirmTextInput to handle edit mode
const _origConfirmText = confirmTextInput;
window.confirmTextInput = function() {
  const val = document.getElementById('textPopupInput').value.trim();
  if (!val) return;
  document.getElementById('textPopup').classList.remove('active');

  // Edi√ß√£o de item da playlist
  if (window._playlistEditConfirmOverride) {
    window._playlistEditConfirmOverride(val);
    return;
  }

  // Check if we're in "edit existing annotation" mode (video only)
  if (window._editingAnnIndex !== undefined && window._editingAnnIndex !== null) {
    const idx = window._editingAnnIndex;
    const editTime = window._editingEditTime;
    window._editingAnnIndex = null;
    window._editingEditTime = null;
    // Buscar pela anota√ß√£o de texto ‚Äî o sort pode ter mudado o √≠ndice, ent√£o busca pelo tipo e tempo mais pr√≥ximo
    let ann = (annotations[currentMediaId] || [])[idx];
    // Se o √≠ndice ficou desatualizado, tentar encontrar pelo _id que foi guardado
    if (!ann || ann.kind !== 'text') {
      ann = (annotations[currentMediaId] || []).find(a => a.kind === 'text' && a._id === window._lastEditingAnnId);
    }
    window._lastEditingAnnId = null;
    if (ann && ann.kind === 'text') {
      if (!ann.edits) ann.edits = [{ time: ann.time, text: ann.text }];
      ann.edits.push({ time: editTime, text: val });
      ann.edits.sort((a, b) => a.time - b.time);
      ann.text = val;
      dismissedTimes.add(editTime);
      annotations[currentMediaId].sort((a, b) => a.time - b.time);
      buildPauseQueue();
      advancePauseQueueTo(video.currentTime);
      renderSavedArrows(video.currentTime);
      renderAnnotationsList();
      updateBadge(currentMediaId);
      showToast('‚úèÔ∏è Texto atualizado', 'success');
    }
    return;
  }

  pendingTextContent = val;
  textEl.childNodes[0].textContent = val;
  if (textMode && window._draggingAnnEdits) {
    const editTime = isImageMode ? 0 : safeAnnotationTime(video.currentTime);
    const existingIdx = window._draggingAnnEdits.findIndex(e => Math.abs(e.time - editTime) < 0.05);
    if (existingIdx >= 0) {
      window._draggingAnnEdits[existingIdx].text = val;
    } else {
      window._draggingAnnEdits.push({ time: editTime, text: val });
      window._draggingAnnEdits.sort((a, b) => a.time - b.time);
    }
  }
  if (!textMode) {
    textMode = true;
    activeMode = 'text';
    textXPct = 50; textYPct = 40;
    textEl.style.fontSize = textFontSize + 'px';
    textEl.style.width = '';
    textEl.style.height = '';
    textEl.style.display = 'block';
    textEl.style.background = TEXT_BG_COLORS[textBgColorIdx].value;
    placeText(textXPct, textYPct);
    if (isImageMode) {
      document.getElementById('imgTextBtn').classList.add('active');
      document.getElementById('imgDoneBtn').style.display = 'flex';
      document.getElementById('imgFontMinusBtn').style.display = 'flex'; document.getElementById('imgFontSizeDisplay').style.display = 'inline-block'; document.getElementById('imgFontSizeDisplay').textContent = textFontSize + 'px';
      document.getElementById('imgFontPlusBtn').style.display = 'flex';
      { const _ib=document.getElementById('imgBgColorBtn'); const _id=document.getElementById('imgBgColorDot'); if(_ib)_ib.style.display='flex'; if(_id)_id.style.background=TEXT_BG_COLORS[textBgColorIdx].dot; }
    } else {
      textBtn.classList.add('active');
      doneBtn.style.display = 'flex';
      document.getElementById('fontMinusBtn').style.display = 'flex'; document.getElementById('fontSizeDisplay').style.display = 'inline-block'; document.getElementById('fontSizeDisplay').textContent = textFontSize + 'px';
      document.getElementById('fontPlusBtn').style.display = 'flex';
      { const _b=document.getElementById('bgColorBtn'); const _d=document.getElementById('bgColorDot'); if(_b)_b.style.display='flex'; if(_d)_d.style.background=TEXT_BG_COLORS[textBgColorIdx].dot; }
    }
  }
  if (isImageMode) {
    document.getElementById('imgEditTextBtn').style.opacity = '1';
    document.getElementById('imgEditTextBtn').style.cursor = 'pointer';
  } else {
    document.getElementById('editTextBtn').style.opacity = '1';
    document.getElementById('editTextBtn').style.cursor = 'pointer';
  }
};


function getAngle(cx, cy, ex, ey) {
  return Math.atan2(ey - cy, ex - cx) * (180 / Math.PI);
}

function startRotate(e, target) {
  e.stopPropagation();
  e.preventDefault();
  isRotating = true;
  rotateTarget = target;
  const el = target === 'arrow' ? arrowEl : textEl;
  const rect = el.getBoundingClientRect();
  rotateCenterX = rect.left + rect.width / 2;
  rotateCenterY = rect.top + rect.height / 2;
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  rotateStartAngle = getAngle(rotateCenterX, rotateCenterY, clientX, clientY);
  rotateStartRot = target === 'arrow' ? arrowRotation : textRotation;
}

document.addEventListener('mousemove', e => {
  if (!isRotating) return;
  const angle = getAngle(rotateCenterX, rotateCenterY, e.clientX, e.clientY);
  const delta = angle - rotateStartAngle;
  if (rotateTarget === 'arrow') {
    arrowRotation = rotateStartRot + delta;
    placeArrow(arrowXPct, arrowYPct);
  }
});

document.addEventListener('touchmove', e => {
  if (!isRotating) return;
  e.preventDefault();
  const touch = e.touches[0];
  const angle = getAngle(rotateCenterX, rotateCenterY, touch.clientX, touch.clientY);
  const delta = angle - rotateStartAngle;
  if (rotateTarget === 'arrow') {
    arrowRotation = rotateStartRot + delta;
    placeArrow(arrowXPct, arrowYPct);
  }
}, { passive: false });

document.getElementById('arrowRotateHandle').addEventListener('mousedown', e => startRotate(e, 'arrow'));
document.getElementById('arrowRotateHandle').addEventListener('touchstart', e => startRotate(e, 'arrow'), { passive: false });

function placeArrow(xPct, yPct) {
  arrowEl.style.left = xPct + '%';
  arrowEl.style.top = yPct + '%';
  arrowEl.style.transform = `translate(-50%, -50%) rotate(${arrowRotation}deg)`;
}

function placeText(xPct, yPct) {
  const overlayRect = overlay.getBoundingClientRect();
  const elW = textEl.offsetWidth || 100;
  const elH = textEl.offsetHeight || 40;
  const px = (xPct / 100) * overlayRect.width - elW / 2;
  const py = (yPct / 100) * overlayRect.height - elH / 2;
  // No clamping ‚Äî allow free movement in all directions
  textEl.style.left = px + 'px';
  textEl.style.top = py + 'px';
  textEl.style.transform = `rotate(${textRotation}deg)`;
  textXPct = ((px + elW / 2) / overlayRect.width) * 100;
  textYPct = ((py + elH / 2) / overlayRect.height) * 100;
}

// ‚îÄ‚îÄ‚îÄ CUSTOM PROGRESS BAR + TRIM HANDLES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const progressTrack = document.getElementById('progressTrack');
const progressFill = document.getElementById('progressFill');
const progressThumb = document.getElementById('progressThumb');
const progressCurrent = document.getElementById('progressCurrent');
const progressDuration = document.getElementById('progressDuration');
const trimHandleStart  = document.getElementById('trimHandleStart');
const trimHandleEnd    = document.getElementById('trimHandleEnd');
const trimMaskLeft     = document.getElementById('trimMaskLeft');
const trimMaskRight    = document.getElementById('trimMaskRight');
const trimRangeBar     = document.getElementById('trimRangeBar');
const trimTooltip      = document.getElementById('trimTooltip');

let progressDragging = false;
let trimDragging      = null; // 'start' | 'end' | null
let _lastTrimTouched  = null; // 'start' | 'end'

function formatShortTime(secs) {
  if (isNaN(secs)) return '00:00';
  const m = Math.floor(secs / 60);
  const s = Math.floor(secs % 60);
  return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
}

// Update all visual elements of the trim range
function updateTrimVisuals() {
  if (!video.duration) return;
  const startPct = (trimStart / video.duration) * 100;
  const endPct   = isFinite(trimEnd) ? (trimEnd / video.duration) * 100 : 100;

  trimHandleStart.style.left = startPct + '%';
  trimHandleEnd.style.left   = endPct + '%';
  trimMaskLeft.style.width   = startPct + '%';
  trimMaskRight.style.width  = (100 - endPct) + '%';
  trimRangeBar.style.left    = startPct + '%';
  trimRangeBar.style.width   = (endPct - startPct) + '%';
}

function setProgressPercent(pct) {
  pct = Math.max(0, Math.min(100, pct));
  progressFill.style.left  = (trimStart && video.duration ? (trimStart / video.duration * 100) : 0) + '%';
  progressFill.style.width = Math.max(0, pct - (trimStart && video.duration ? trimStart / video.duration * 100 : 0)) + '%';
  progressThumb.style.left = pct + '%';
}

let progressScrubbing = false; // separate from internalSeek

function scrubToEvent(e) {
  const rect = progressTrack.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const pct = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
  if (video.duration) {
    progressScrubbing = true;
    const rawTime = pct * video.duration;
    const clampedTime = Math.max(trimStart, Math.min(isFinite(trimEnd) ? trimEnd : video.duration, rawTime));
    video.currentTime = clampedTime;
    setProgressPercent((clampedTime / video.duration) * 100);
    progressCurrent.textContent = formatShortTime(clampedTime);
  }
}

// ‚îÄ‚îÄ Trim handle drag ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function onTrimHandleDown(e, which) {
  e.stopPropagation();
  e.preventDefault();
  trimDragging = which;
  _lastTrimTouched = which;
  window._trimUndoSnapshot = { start: trimStart, end: trimEnd, which };
  if (!video.paused) video.pause();
  trimTooltip.style.display = 'block';
}

trimHandleStart.addEventListener('mousedown',  e => onTrimHandleDown(e, 'start'));
trimHandleStart.addEventListener('touchstart', e => onTrimHandleDown(e, 'start'), { passive: false });
trimHandleEnd.addEventListener('mousedown',    e => onTrimHandleDown(e, 'end'));
trimHandleEnd.addEventListener('touchstart',   e => onTrimHandleDown(e, 'end'), { passive: false });

function onTrimHandleMove(e) {
  if (!trimDragging) return;
  const rect = progressTrack.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const pct = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
  const t = pct * video.duration;
  const MIN_GAP = 0.5;

  if (trimDragging === 'start') {
    trimStart = Math.max(0, Math.min(t, (isFinite(trimEnd) ? trimEnd : video.duration) - MIN_GAP));
    if (video.currentTime < trimStart) {
      internalSeek = true;
      video.currentTime = trimStart;
    }
    trimTooltip.style.left = (trimStart / video.duration * 100) + '%';
    trimTooltip.textContent = '‚ñ∂ ' + formatShortTime(trimStart);
  } else {
    trimEnd = Math.min(video.duration, Math.max(t, trimStart + MIN_GAP));
    if (video.currentTime > trimEnd) {
      internalSeek = true;
      video.currentTime = trimEnd;
    }
    trimTooltip.style.left = (trimEnd / video.duration * 100) + '%';
    trimTooltip.textContent = '‚ñ† ' + formatShortTime(trimEnd);
  }
  updateTrimVisuals();
  setProgressPercent((video.currentTime / video.duration) * 100);
  progressCurrent.textContent = formatShortTime(video.currentTime);
}

function onTrimHandleUp() {
  if (!trimDragging) return;
  const wasStart = trimDragging === 'start';
  trimDragging = null;
  trimTooltip.style.display = 'none';
  buildPauseQueue();
  advancePauseQueueTo(video.currentTime);
  if (wasStart && video.duration) {
    internalSeek = true;
    video.currentTime = trimStart;
    renderSavedArrows(trimStart);
  }
}

document.addEventListener('mousemove', e => { onTrimHandleMove(e); });
document.addEventListener('touchmove', e => { if (trimDragging) { e.preventDefault(); onTrimHandleMove(e); } }, { passive: false });
document.addEventListener('mouseup',  onTrimHandleUp);
document.addEventListener('touchend', onTrimHandleUp);

progressTrack.addEventListener('mousedown', e => {
  if (trimHandleStart.contains(e.target) || trimHandleEnd.contains(e.target)) return;
  progressDragging = true;
  if (!video.paused) video.pause();
  scrubToEvent(e);
});
progressTrack.addEventListener('touchstart', e => {
  if (trimHandleStart.contains(e.target) || trimHandleEnd.contains(e.target)) return;
  progressDragging = true;
  if (!video.paused) video.pause();
  scrubToEvent(e);
}, { passive: true });

document.addEventListener('mousemove', e => {
  if (progressDragging) scrubToEvent(e);
});
document.addEventListener('touchmove', e => {
  if (progressDragging) scrubToEvent(e);
}, { passive: true });

document.addEventListener('mouseup', () => { progressDragging = false; });
document.addEventListener('touchend', () => { progressDragging = false; });

video.addEventListener('timeupdate', () => {
  // Enforce trim: if playing before trimStart, jump to it
  if (trimStart > 0 && video.currentTime < trimStart && !video.paused) {
    internalSeek = true;
    video.currentTime = trimStart;
    return;
  }
  // Enforce trimEnd: pause at the end mark
  if (isFinite(trimEnd) && video.currentTime >= trimEnd && !video.paused) {
    video.pause();
    rewindOnNextPlay = true;
    return;
  }
  if (progressDragging) return;
  if (video.duration) {
    const pct = (video.currentTime / video.duration) * 100;
    setProgressPercent(pct);
  }
  progressCurrent.textContent = formatShortTime(video.currentTime);
});

video.addEventListener('loadedmetadata', () => {
  progressDuration.textContent = formatShortTime(video.duration);
  setProgressPercent(0);
  trimStart = 0;
  trimEnd = Infinity;
  updateTrimVisuals();
  updateAnnotationMarkers(); updateStoryButtons();
  renderSkipZones();
  buildPauseQueue(); pauseQueueIdx = 0;
  // Reposicionar playlist ap√≥s o v√≠deo definir seu tamanho
  requestAnimationFrame(() => renderTextPlaylist());
});


let dismissedTimes = new Set(); // times the user explicitly skipped
let internalSeek = false;      // flag: seeked was triggered by annotation, not user

video.addEventListener('timeupdate', () => {
  const t = video.currentTime;
  tsDisplay.textContent = formatTime(t);
  renderSavedArrows(t);
  updateCheckmarkOverlay(t);
  updateXmarkOverlay(t);
  // If line_highlight or text annotations are active, keep text visible during play
  if (!video.paused && !arrowMode && !textMode) {
    const anns = annotations[currentMediaId] || [];
    if (anns.some(a => a.kind === 'line_highlight' || a.kind === 'text' || !a.kind || a.kind === 'arrow')) renderSavedArrowsDuringPlay();
  }

  if (arrowMode || textMode) return;

  if (screenRecordMode) {
    const anns = annotations[currentMediaId] || [];
    for (const ann of anns) {
      if (dismissedTimes.has(ann.time)) continue;
      if (t >= ann.time && t <= ann.time + 0.15) {
        dismissedTimes.add(ann.time);
        video.pause();
        // Auto-resume after 2 seconds
        screenRecordPauseTimeout = setTimeout(() => {
          if (screenRecordMode) {
            video.play();
          }
        }, 2000);
        break;
      }
    }
    return;
  }

  checkAndPauseAtAnnotation();
});

// ‚îÄ‚îÄ‚îÄ STOPWATCH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let swStartTime = null;
let swRunning = false;
let swRaf = null;

function swReset() {
  swStartTime = null;
  swRunning = false;
  if (swRaf) { cancelAnimationFrame(swRaf); swRaf = null; }
  const el = document.getElementById('stopwatch');
  if (el) el.textContent = '0.000';
}

function swStart() {
  if (swRunning) return;
  swRunning = true;
  swStartTime = performance.now();
  function tick() {
    if (!swRunning) return;
    const el = document.getElementById('stopwatch');
    if (el) {
      const ms = performance.now() - swStartTime;
      const secs = Math.floor(ms / 1000);
      const millis = Math.floor(ms % 1000);
      el.textContent = `${secs}.${String(millis).padStart(3,'0')}`;
    }
    swRaf = requestAnimationFrame(tick);
  }
  swRaf = requestAnimationFrame(tick);
}

function swStop() {
  swRunning = false;
  if (swRaf) { cancelAnimationFrame(swRaf); swRaf = null; }
}

function playAnnotationSound(key) {
  // Only play on start (A) points, never on end (B) points
  if (!key || !key.includes('_start_')) return;
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    if (key.startsWith('checkmark')) {
      // ‚úÖ Happy, upbeat fanfare ‚Äî rising major arpeggio
      const notes = [523.25, 659.25, 783.99, 1046.50]; // C5 E5 G5 C6
      notes.forEach((freq, i) => {
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g); g.connect(ctx.destination);
        o.type = 'triangle';
        const t = ctx.currentTime + i * 0.10;
        o.frequency.setValueAtTime(freq, t);
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.35, t + 0.04);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
        o.start(t);
        o.stop(t + 0.26);
      });
    } else if (key.startsWith('xmark')) {
      // ‚ùå Double thud ‚Äî imperative "STOP", two heavy hits
      const t = ctx.currentTime;
      [0, 0.22].forEach(offset => {
        // Low body thud
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain); gain.connect(ctx.destination);
        osc.type = 'sine';
        const st = t + offset;
        osc.frequency.setValueAtTime(120, st);
        osc.frequency.exponentialRampToValueAtTime(55, st + 0.12);
        gain.gain.setValueAtTime(0, st);
        gain.gain.linearRampToValueAtTime(0.9, st + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, st + 0.18);
        osc.start(st);
        osc.stop(st + 0.19);
        // High snap layer on top
        const osc2 = ctx.createOscillator();
        const gain2 = ctx.createGain();
        osc2.connect(gain2); gain2.connect(ctx.destination);
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(280, st);
        osc2.frequency.exponentialRampToValueAtTime(100, st + 0.08);
        gain2.gain.setValueAtTime(0, st);
        gain2.gain.linearRampToValueAtTime(0.35, st + 0.005);
        gain2.gain.exponentialRampToValueAtTime(0.001, st + 0.10);
        osc2.start(st);
        osc2.stop(st + 0.11);
      });
    }
  } catch(e) {}
}

let slowMoTimeout = null;

// ‚îÄ‚îÄ‚îÄ SORTED PAUSE QUEUE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Instead of time-window detection (which misses same-second annotations),
// we maintain a sorted queue of trigger points. Each point knows its exact time
// and a unique key. We seek to the next point and pause precisely.

let pauseQueue = [];      // [{time, key}] sorted ascending
let pauseQueueIdx = 0;    // index of next point to fire

function buildPauseQueue() {
  const anns = annotations[currentMediaId] || [];
  const pts = [];
  for (const ann of anns) {
    if (ann.kind === 'checkmark' || ann.kind === 'xmark') {
      pts.push({ time: ann.timeStart, key: `${ann.kind}_start_${ann.timeStart}_${ann.time}` });
      pts.push({ time: ann.timeEnd,   key: `${ann.kind}_end_${ann.timeEnd}_${ann.time}` });
    } else if (ann.kind === 'line_highlight') {
      pts.push({ time: ann.time, key: `line_highlight_${ann._id}_${ann.time}` });
    } else if (ann.kind === 'text' && ann.edits && ann.edits.length > 0) {
      for (const edit of ann.edits) {
        pts.push({ time: edit.time, key: `text_edit_${ann._id}_${edit.time}` });
      }
      // Tamb√©m incluir ann.time se diferente dos edits (garante pause na inser√ß√£o original)
      if (!ann.edits.some(e => Math.abs(e.time - ann.time) < 0.05)) {
        pts.push({ time: ann.time, key: `text_orig_${ann._id}_${ann.time}` });
      }
    } else if (ann.kind === 'photo') {
      pts.push({ time: ann.time, key: `photo_${ann._id}_${ann.time}` });
    } else if ((!ann.kind || ann.kind === 'arrow') && ann.moves && ann.moves.length > 0) {
      for (const move of ann.moves) {
        pts.push({ time: move.time, key: `arrow_move_${ann._id}_${move.time}` });
      }
    } else {
      // Usar _id se dispon√≠vel para garantir unicidade entre m√∫ltiplas anota√ß√µes no mesmo tempo
      const key = ann._id ? `plain_${ann._id}_${ann.time}` : `plain_${ann.time}`;
      pts.push({ time: ann.time, key });
    }
  }
  // Itens do üì¶ move n√£o geram pontos de pausa
  pts.sort((a, b) => a.time - b.time);
  const seen = new Set();
  pauseQueue = pts.filter(p => { if (seen.has(p.key)) return false; seen.add(p.key); return true; });
  pauseQueueIdx = 0; // sempre resetar ‚Äî dismissed filtra os j√° visitados
}

function advancePauseQueueTo(t) {
  // Move queue index to the first point >= t
  pauseQueueIdx = 0;
  while (pauseQueueIdx < pauseQueue.length && pauseQueue[pauseQueueIdx].time < t - 0.1) {
    pauseQueueIdx++;
  }
}

function getNextPausePoint(t) {
  for (let i = pauseQueueIdx; i < pauseQueue.length; i++) {
    const pt = pauseQueue[i];
    if (dismissedTimes.has(pt.key)) continue;
    if (pt.time >= t - 0.05) return { pt, i };
  }
  return null;
}

let seekingToPause = false; // reserved for future use
let userResuming = false;   // skip one check cycle after manual play to avoid immediate re-pause
let lastPausedKey = null;   // key of the last annotation point we paused on
let _lastAnnotationPauseTime = null; // tempo do √∫ltimo pause de texto/playlist (para rewind)

function checkAndPauseAtAnnotation() {
  if (arrowMode || textMode || screenRecordMode || video.paused) return;
  const t = video.currentTime;
  if (userResuming) {
    userResuming = false;
    // Skip only if the very next undismissed point is the one we just came from
    const next = getNextPausePoint(t);
    if (!next || next.pt.key === lastPausedKey) return;
    // It's a different point ahead ‚Äî fall through and detect it
  }
  const next = getNextPausePoint(t);
  if (!next) return;
  const { pt, i } = next;
  if (t >= pt.time - 0.05 && t <= pt.time + 0.4) {
    lastPausedKey = pt.key;
    dismissedTimes.add(pt.key);
    pauseQueueIdx = i + 1;
    // N√£o pausar para textos
    const isTextPoint = pt.key && (pt.key.startsWith('text_edit_') || pt.key.startsWith('text_orig_'));
    if (!isTextPoint) video.pause();
    playAnnotationSound(pt.key);
    updateCheckmarkOverlay(pt.time);
    updateXmarkOverlay(pt.time);
    if (pt.key && pt.key.startsWith('plain_')) {
      _lastAnnotationPauseTime = pt.time;
    }
    // Show static overlay immediately
    const anns2 = annotations[currentMediaId] || [];
    const inCheck2 = anns2.find(a => a.kind === 'checkmark' && Math.abs(pt.time - a.timeStart) < 0.05);
    const inX2 = anns2.find(a => a.kind === 'xmark' && Math.abs(pt.time - a.timeStart) < 0.05);
    if (inCheck2) showStaticOverlay('checkmark');
    else if (inX2) showStaticOverlay('xmark');
  }
}

function checkAndPauseScreenRecord() {
  if (!screenRecordMode || video.paused) return;
  const t = video.currentTime;
  const next = getNextPausePoint(t);
  if (!next) return;
  const { pt, i } = next;
  if (t >= pt.time - 0.05 && t <= pt.time + 0.4) {
    dismissedTimes.add(pt.key);
    pauseQueueIdx = i + 1;
    video.pause(); playAnnotationSound(pt.key);
    updateCheckmarkOverlay(pt.time);
    updateXmarkOverlay(pt.time);
    clearTimeout(screenRecordPauseTimeout);
    screenRecordPauseTimeout = setTimeout(() => { if (screenRecordMode) video.play(); }, 2000);
  }
}

// RAF loop: checks every animation frame while playing (more reliable on mobile)
function rafPauseLoop() {
  if (!video.paused) {
    // Enforce trimEnd com alta precis√£o (~60fps) ‚Äî evita vazar frames al√©m do ponto B
    if (isFinite(trimEnd) && video.currentTime >= trimEnd) {
      video.pause();
      internalSeek = true;
      video.currentTime = trimEnd;
      if (trimLoop) {
        // Loop: voltar ao in√≠cio sem parar
        dismissedTimes.clear();
        pauseQueueIdx = 0;
        lastPausedKey = null;
        _lastAnnotationPauseTime = null;
        const loopStart = trimStart > 0 ? trimStart : 0;
        video.currentTime = loopStart;
        video.addEventListener('seeked', function onLoopSeeked() {
          video.removeEventListener('seeked', onLoopSeeked);
          internalSeek = false;
          video.play();
        }, { once: true });
      } else {
        rewindToTime = _lastAnnotationPauseTime !== null ? _lastAnnotationPauseTime : null;
        rewindOnNextPlay = true;
        renderSavedArrows(trimEnd);
      }
      return;
    }
    checkAndSkipBlock();
    if (screenRecordMode) {
      checkAndPauseScreenRecord();
    } else {
      checkAndPauseAtAnnotation();
    }
    updateCheckmarkOverlay(video.currentTime);
    updateXmarkOverlay(video.currentTime);
    requestAnimationFrame(rafPauseLoop);
  }
}
video.addEventListener('play', () => { requestAnimationFrame(rafPauseLoop); });

// ‚îÄ‚îÄ‚îÄ CLICK ZONE HANDLER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function handleVideoClick() {
  if (window._selectedPhotoId) {
    window._selectedPhotoId = null;
    renderSavedArrows(video.currentTime);
    return;
  }
  if (selectedAnnIndex !== null) {
    selectedAnnIndex = null; renderSavedArrows();
    const editBtn = document.getElementById('editTextBtn');
    editBtn.style.opacity = '0.35'; editBtn.style.cursor = 'not-allowed';
    return;
  }
  if (arrowMode || textMode) { showToast('Conclua ou desfa√ßa a anota√ß√£o antes de continuar.', 'error'); return; }
  if (screenRecordMode) { toggleRecordPausePlay(); return; }
  if (video.paused) {
    // Se chegou no fim do trim, reinicia do trimStart direto no clique
    if (rewindOnNextPlay || (isFinite(trimEnd) && video.currentTime >= trimEnd - 0.05)) {
      rewindOnNextPlay = false;
      const seekTo = trimStart > 0 ? trimStart : 0;
      rewindToTime = null;
      // Rearms all dismissed annotation points from seekTo
      for (const key of [...dismissedTimes]) {
        let keyTime = parseFloat(key);
        if (isNaN(keyTime)) {
          const m = key.match(/_(\d+\.?\d*)(?:_\d+\.?\d*)?$/);
          if (m) keyTime = parseFloat(m[1]);
        }
        if (!isNaN(keyTime) && keyTime >= seekTo - 0.05) dismissedTimes.delete(key);
      }
      pauseQueueIdx = 0;
      lastPausedKey = null;
      internalSeek = true;
      video.currentTime = seekTo;
      video.addEventListener('seeked', function onClickRewind() {
        video.removeEventListener('seeked', onClickRewind);
        internalSeek = false;
        userResuming = true;
        video.play();
      }, { once: true });
    } else {
      userResuming = true;
      video.play();
    }
  } else {
    if (trimLoop) { trimLoop = false; toggleTrimLoop(); trimLoop = false; const btn = document.getElementById('loopBtn'); if(btn){btn.style.color='';btn.style.borderColor='';btn.style.background='';} }
    video.pause();
  }
}

// ‚îÄ‚îÄ‚îÄ BLOCK PLAY DURING EDIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
video.addEventListener('play', () => {
  hideStaticOverlays();
  // Re-sync pause queue on every play in case seek happened just before
  advancePauseQueueTo(video.currentTime);
  selectedAnnIndex = null;
  if (arrowMode || textMode) {
    video.pause();
    showToast('Conclua ou desfa√ßa a anota√ß√£o antes de continuar.', 'error');
    return;
  }
  // Only clear if no line_highlight is active ‚Äî otherwise keep text visible
  const anns = annotations[currentMediaId] || [];
  const hasLineHighlight = anns.some(a => a.kind === 'line_highlight');
  const hasTextAnns = anns.some(a => a.kind === 'text');
  const hasArrowAnns2 = anns.some(a => !a.kind || a.kind === 'arrow');
  if (!hasLineHighlight && !hasTextAnns && !hasArrowAnns2) {
    savedArrowsContainer.innerHTML = '';
  } else {
    // Re-render with current time so text stays visible
    renderSavedArrowsDuringPlay();
  }
});

function renderSavedArrowsDuringPlay() {
  renderSavedArrows(video.currentTime);
}

video.addEventListener('pause', () => {
  if (arrowMode || textMode) return;
  swStop();
  updateCheckmarkOverlay(video.currentTime);
  updateXmarkOverlay(video.currentTime);
});

video.addEventListener('ended', () => {
  swStop(); swReset();
  if (screenRecordMode) stopScreenRecord();
  internalSeek = true;
  video.currentTime = trimStart > 0 ? trimStart : 0;
});

video.addEventListener('play', () => {
  updateCheckmarkOverlay(video.currentTime);
  updateXmarkOverlay(video.currentTime);
  swReset(); swStart();

  if (rewindOnNextPlay) {
    rewindOnNextPlay = false;
    const seekTo = rewindToTime !== null ? rewindToTime : (trimStart > 0 ? trimStart : 0);
    rewindToTime = null;
    video.pause();
    internalSeek = true;
    video.currentTime = seekTo;
    video.addEventListener('seeked', function onRewind() {
      video.removeEventListener('seeked', onRewind);
      // Re-armar todos os pontos a partir de seekTo
      for (const key of [...dismissedTimes]) {
        let keyTime = parseFloat(key);
        if (isNaN(keyTime)) {
          const m = key.match(/_(\d+\.?\d*)(?:_\d+\.?\d*)?$/);
          if (m) keyTime = parseFloat(m[1]);
        }
        if (!isNaN(keyTime) && keyTime >= seekTo - 0.05) dismissedTimes.delete(key);
      }
      pauseQueueIdx = 0; // garantir que a fila come√ßa do zero
      video.play();
    }, { once: true });
  }
});

// ‚îÄ‚îÄ‚îÄ UNDO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function undoLastEmojiAnnotation() {
  const anns = annotations[currentMediaId] || [];

  // If there's a pending half-annotation (first click done), cancel it
  if (checkmarkPending) {
    checkmarkPending = false;
    checkmarkStart = null;
    const btn = document.getElementById('checkBtn');
    const content = document.getElementById('checkBtnContent');
    if (btn) { btn.style.color = ''; btn.style.borderColor = ''; btn.style.background = ''; }
    if (content) content.textContent = '‚úÖ';
    updateAnnotationMarkers(); updateStoryButtons();
    showToast('‚Ü© ‚úÖ cancelado.', '');
    return;
  }
  if (xmarkPending) {
    xmarkPending = false;
    xmarkStart = null;
    const btn = document.getElementById('xmarkBtn');
    const content = document.getElementById('xmarkBtnContent');
    if (btn) { btn.style.color = ''; btn.style.borderColor = ''; btn.style.background = ''; }
    if (content) content.textContent = '‚ùå';
    updateAnnotationMarkers(); updateStoryButtons();
    showToast('‚Ü© ‚ùå cancelado.', '');
    return;
  }
  if (skipPending !== null) {
    skipPending = null;
    const btn = document.getElementById('skipBlockBtn');
    if (btn) { btn.style.color = ''; btn.style.borderColor = ''; btn.style.background = ''; btn.innerHTML = '‚¨õ'; }
    renderSkipZones();
    showToast('‚Ü© ‚¨õ cancelado.', '');
    return;
  }

  // Find the most recently added checkmark, xmark among saved annotations
  const emojiKinds = ['checkmark', 'xmark'];
  // Find last saved emoji annotation (by _id order ‚Äî highest counter = last added)
  let lastEmoji = null;
  let lastEmojiIdx = -1;
  for (let i = 0; i < anns.length; i++) {
    const a = anns[i];
    if (emojiKinds.includes(a.kind)) {
      // Pick the one with highest _annCounter (embedded in _id)
      if (!lastEmoji || _annIdNum(a._id) > _annIdNum(lastEmoji._id)) {
        lastEmoji = a;
        lastEmojiIdx = i;
      }
    }
  }

  // Also check if last skipPair should be removed
  if (skipPairs.length > 0) {
    const lastSkipId = skipPairs[skipPairs.length - 1]._id || 0;
    const lastEmojiId = lastEmoji ? _annIdNum(lastEmoji._id) : 0;
    if (!lastEmoji || lastSkipId > lastEmojiId) {
      const removed = skipPairs.pop();
      emojiRedoStack.push({ type: 'skip', data: removed, mediaId: currentMediaId });
      updateSkipBtn();
      renderSkipZones();
      showToast('‚Ü© √öltimo ‚¨õ removido.', '');
      return;
    }
  }

  if (lastEmojiIdx === -1) {
    showToast('Nenhum ‚úÖ‚ùå‚¨õ para desfazer.', 'error');
    return;
  }

  const removed = anns.splice(lastEmojiIdx, 1)[0];
  emojiRedoStack.push({ type: 'ann', data: removed, mediaId: currentMediaId });
  dismissedTimes = new Set();
  buildPauseQueue();
  renderSavedArrows();
  renderAnnotationsList();
  updateBadge(currentMediaId);
  updateAnnotationMarkers(); updateStoryButtons();
  renderSkipZones();
  showToast('‚Ü© √öltima ‚úÖ‚ùå removida.', '');
}

function redoLastEmojiAnnotation() {
  if (emojiRedoStack.length === 0) {
    showToast('Nada para refazer.', 'error');
    return;
  }
  const entry = emojiRedoStack.pop();
  if (entry.mediaId !== currentMediaId) {
    emojiRedoStack.push(entry); // put it back, wrong media
    showToast('Refazer n√£o dispon√≠vel para este v√≠deo.', 'error');
    return;
  }
  if (entry.type === 'skip') {
    skipPairs.push(entry.data);
    updateSkipBtn();
    renderSkipZones();
    showToast('‚Ü™ ‚¨õ refeito.', 'success');
  } else if (entry.type === 'ann') {
    const anns = annotations[currentMediaId];
    anns.push(entry.data);
    anns.sort((a, b) => a.time - b.time);
    dismissedTimes = new Set();
    buildPauseQueue();
    renderSavedArrows();
    renderAnnotationsList();
    updateBadge(currentMediaId);
    updateAnnotationMarkers(); updateStoryButtons();
    renderSkipZones();
    const icon = entry.data.kind === 'checkmark' ? '‚úÖ' : '‚ùå';
    showToast(`‚Ü™ ${icon} refeito.`, 'success');
  }
}

function _annIdNum(id) {
  if (!id) return 0;
  const m = id.match(/^_ann_(\d+)/);
  return m ? parseInt(m[1]) : 0;
}

function undoLastAnnotation() {
  // If currently in edit mode, just cancel without saving
  if (arrowMode || textMode) {
    cancelAll();
    showToast('Anota√ß√£o cancelada.', '');
    return;
  }
  // Otherwise remove last saved annotation (by id, not array position ‚Äî array is sorted by time)
  const anns = annotations[currentMediaId];
  if (!anns || anns.length === 0) {
    showToast('Nenhuma anota√ß√£o para desfazer.', 'error');
    return;
  }
  const idx = lastSavedAnnId ? anns.findIndex(a => a._id === lastSavedAnnId) : anns.length - 1;
  if (idx !== -1) {
    anns.splice(idx, 1);
    lastSavedAnnId = anns.length > 0 ? (anns[anns.length - 1]._id || null) : null;
  }
  dismissedTimes = new Set(); // re-arm remaining
  renderSavedArrows();
  renderAnnotationsList();
  updateBadge(currentMediaId);
  updateAnnotationMarkers(); updateStoryButtons();
  showToast('‚Ü© √öltima anota√ß√£o removida.', '');
}

video.addEventListener('seeked', () => {
  const t = video.currentTime;
  if (internalSeek) {
    internalSeek = false;
    // Se voltou ao in√≠cio (trimStart ou 0), re-armar TODAS as pausas
    const startPos = trimStart > 0 ? trimStart : 0;
    if (t <= startPos + 0.3) {
      dismissedTimes.clear();
      pauseQueueIdx = 0;
      selectedAnnIndex = null;
      lastPausedKey = null;
      _lastAnnotationPauseTime = null;
      rewindToTime = null;
      renderTextPlaylist();
    }
    // pauseQueueIdx j√° √© 0 ap√≥s buildPauseQueue ‚Äî n√£o avan√ßar aqui
    renderSavedArrows(t);
    updateCheckmarkOverlay(t);
    updateXmarkOverlay(t);
    if (video.paused) {
      const anns = annotations[currentMediaId] || [];
      const inCheck = anns.find(a => a.kind === 'checkmark' && Math.abs(t - a.timeStart) < 0.05);
      const inX = anns.find(a => a.kind === 'xmark' && Math.abs(t - a.timeStart) < 0.05);
      if (inCheck) showStaticOverlay('checkmark');
      else if (inX) showStaticOverlay('xmark');
      else hideStaticOverlays();
    }
    return;
  }
  // User-initiated seek: re-arm annotations ahead of new position
  progressScrubbing = false;
  _lastAnnotationPauseTime = null;
  rewindToTime = null;
  selectedAnnIndex = null;
  lastPausedKey = null;
  const startPos = trimStart > 0 ? trimStart : 0;
  if (t <= startPos + 0.3) {
    // Arrastou para o in√≠cio ‚Äî zerar tudo
    dismissedTimes.clear();
    pauseQueueIdx = 0;
    renderTextPlaylist();
  } else {
    // Arrastou para um ponto no meio ‚Äî re-armar pontos adiante
    // Extrair tempo do final da key: √∫ltimo n√∫mero decimal na string
    for (const key of [...dismissedTimes]) {
      const m = key.match(/(\d+(?:\.\d+)?)$/);
      const keyTime = m ? parseFloat(m[1]) : NaN;
      if (!isNaN(keyTime) && keyTime > t + 0.05) dismissedTimes.delete(key);
    }
    pauseQueueIdx = 0;
  }
  advancePauseQueueTo(t);
});

// ‚îÄ‚îÄ‚îÄ SAVED ARROWS RENDERING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function arrowSVG() {
  return `<svg viewBox="0 0 80 80" fill="none" width="72" height="72">
    <defs>
      <filter id="glow2">
        <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
        <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>
    <g filter="url(#glow2)">
      <line x1="14" y1="66" x2="56" y2="24" stroke="#e8ff47" stroke-width="5" stroke-linecap="round"/>
      <polygon points="56,24 38,26 54,42" fill="#e8ff47"/>
      <circle cx="14" cy="66" r="5" fill="#e8ff47" opacity="0.6"/>
    </g>
  </svg>`;
}

function renderSavedArrows(currentTime) {
  savedArrowsContainer.innerHTML = '';
  const anns = annotations[currentMediaId] || [];
  const t = isImageMode ? 0 : (currentTime !== undefined ? currentTime : video.currentTime);

  // Find active line_highlight: the latest one whose time <= t + 0.5
  let activeLine = -1;
  for (const ann of anns) {
    if (ann.kind === 'line_highlight' && ann.time <= t + 0.5) {
      activeLine = ann.lineIndex;
    }
  }
  const lineHighlightActive = activeLine >= 0;

  // Normal render gate ‚Äî bypass if line highlight is active OR if there are text annotations (text persists during play)
  const hasTextAnns = anns.some(a => a.kind === 'text');
  const hasArrowAnns = anns.some(a => !a.kind || a.kind === 'arrow');
  const hasPhotoAnns = anns.some(a => a.kind === 'photo');
  const shouldRender = isImageMode
    ? (!arrowMode && !textMode)
    : ((video.paused || lineHighlightActive || hasTextAnns || hasArrowAnns || hasPhotoAnns) && !arrowMode && !textMode && !photoMode);
  if (!shouldRender) return;

  anns.forEach(ann => {
    if (ann.kind === 'line_highlight') return; // never render as visual element
    // Text stays visible once line highlight is active; other annotations use normal proximity rule
    if (!isImageMode) {
      if (ann.kind === 'text' && lineHighlightActive) {
        // always show ‚Äî no filter
      } else if (ann.kind === 'text') {
        // Show text from its insertion time up to the trimEnd that was active when it was created
        if (t < ann.time - 0.05) return; // not yet reached
        const annTrimEnd = ann.trimEndAt; // trimEnd salvo no momento da cria√ß√£o
        if (annTrimEnd != null && t > annTrimEnd + 0.05) return; // past saved trimEnd ‚Äî hide
      } else if (ann.kind === 'photo') {
        if (t < ann.time - 0.05) return;
        const annTrimEnd = ann.trimEndAt;
        if (annTrimEnd != null && t > annTrimEnd + 0.05) return;
      } else if (!ann.kind || ann.kind === 'arrow') {
        // Show arrow only when paused at its exact time (not during playback)
        if (t < ann.time - 0.05) return; // not yet reached
        if (!video.paused && t > ann.time + 0.05) return; // playing past it ‚Äî hide
      } else if (Math.abs(t - ann.time) > 0.5) {
        return;
      }
    }
    // Resolve arrow position/rotation from moves[] based on current time
    let annXPct = ann.xPct, annYPct = ann.yPct, annRot = ann.rotation || 0;
    if (!isImageMode && (!ann.kind || ann.kind === 'arrow') && ann.moves && ann.moves.length > 0) {
      for (const move of ann.moves) {
        if (move.time <= t + 0.05) { annXPct = move.xPct; annYPct = move.yPct; annRot = move.rotation || 0; }
      }
    }
    const rot = (ann.kind === 'text') ? (ann.rotation || 0) : annRot;
    const div = document.createElement('div');
      // Position using px for text (consistent with placeText), % for arrows
      if (ann.kind === 'text') {
        const oRect = overlay.getBoundingClientRect();
        let elW = 100;
        if (ann.customWidth) {
          elW = ann.customWidth.endsWith('%') ? parseFloat(ann.customWidth) / 100 * oRect.width : parseFloat(ann.customWidth);
        }
        const px = (ann.xPct / 100) * oRect.width - elW / 2;
        const py = (ann.yPct / 100) * oRect.height - 20;
        div.style.cssText = `position:absolute;left:${px}px;top:${py}px;transform:rotate(${rot}deg);pointer-events:none;`;
      } else {
        div.style.cssText = `position:absolute;left:${annXPct}%;top:${annYPct}%;transform:translate(-50%,-50%) rotate(${rot}deg);pointer-events:none;`;
      }
      if (!ann.kind || ann.kind === 'arrow') {
        div.style.filter = 'drop-shadow(0 2px 8px rgba(0,0,0,0.8))';
        div.style.pointerEvents = 'all';
        div.style.cursor = 'pointer';
        div.innerHTML = arrowSVG();
        // ‚§¢ Move button on the arrow
        const arrowMoveBadge = document.createElement('button');
        arrowMoveBadge.title = 'Mover seta neste momento';
        arrowMoveBadge.innerHTML = '&#x2922;';
        arrowMoveBadge.style.cssText = `position:absolute;top:-14px;left:50%;transform:translateX(-50%);width:26px;height:26px;border-radius:50%;background:#0a0a0c;border:2px solid #e8ff47;color:#e8ff47;font-size:13px;display:flex;align-items:center;justify-content:center;cursor:pointer;pointer-events:all;z-index:30;padding:0;box-shadow:0 2px 8px rgba(0,0,0,0.6);`;
        const arrowAnnIndex = anns.indexOf(ann);
        arrowMoveBadge.onclick = (e) => { e.stopPropagation(); moveArrowAtTime(arrowAnnIndex); };
        div.style.position = 'relative';
        div.appendChild(arrowMoveBadge);
      } else {
        const annIndex = anns.indexOf(ann);
        const isSelected = selectedAnnIndex === annIndex;
        div.style.cssText += `
          background:${ann.bgColor || 'rgba(232,255,71,0.92)'};
          color:#0a0a0c;
          font-family:'Syne',sans-serif;
          font-weight:700;
          font-size:${ann.fontSize || 10}px;
          padding:0;
          border-radius:6px;
          box-shadow:0 4px 20px rgba(0,0,0,0.6);
          white-space:${ann.customWidth ? 'pre-wrap' : 'nowrap'};
          cursor:pointer;
          pointer-events:all;
          z-index:25;
          outline: ${isSelected ? '3px solid #fff' : '2px dashed transparent'};
          outline-offset: 3px;
          transition: outline 0.15s;
          overflow:hidden;
        `;
        if (ann.customWidth) {
          if (ann.customWidth.endsWith('%')) {
            const oRect = overlay.getBoundingClientRect();
            div.style.width = (parseFloat(ann.customWidth) / 100 * oRect.width) + 'px';
          } else {
            div.style.width = ann.customWidth;
          }
          div.style.maxWidth = 'none';
        }
        if (ann.customHeight) {
          div.style.height = ann.customHeight;
          div.style.overflow = 'hidden';
        }

        // Render lines ‚Äî highlight activeLine if set
        const displayText = ann.text || '';
        const lines = displayText.split('\n');
        if (activeLine >= 0) {
          lines.forEach((line, i) => {
            const span = document.createElement('span');
            span.style.cssText = `display:block;padding:6px 14px;${i === activeLine ? 'background:rgba(34,197,94,0.35);border-left:4px solid #22c55e;' : ''}`;
            span.textContent = line || '\u00a0';
            div.appendChild(span);
          });
        } else {
          div.style.padding = '6px 14px';
          div.textContent = displayText;
        }

        // ‚úè Edit button (top-right) ‚Äî mant√©m para acesso direto
        const editBadge = document.createElement('button');
        editBadge.title = 'Editar texto neste momento';
        editBadge.innerHTML = '‚úè';
        editBadge.style.cssText = `position:absolute;top:-20px;right:-20px;width:44px;height:44px;border-radius:50%;background:#0a0a0c;border:2px solid #e8ff47;color:#e8ff47;font-size:18px;display:flex;align-items:center;justify-content:center;cursor:pointer;pointer-events:all;z-index:30;padding:0;box-shadow:0 2px 10px rgba(0,0,0,0.7);`;
        editBadge.onclick = (e) => { e.stopPropagation(); editSavedTextById(ann._id); };
        div.appendChild(editBadge);

        // ‚§¢ Move/resize button (top-left)
        const moveBadge = document.createElement('button');
        moveBadge.title = 'Mover / redimensionar';
        moveBadge.innerHTML = '&#x2922;';
        moveBadge.style.cssText = `position:absolute;top:-20px;left:-20px;width:44px;height:44px;border-radius:50%;background:#0a0a0c;border:2px solid rgba(255,255,255,0.7);color:#fff;font-size:20px;display:flex;align-items:center;justify-content:center;cursor:pointer;pointer-events:all;z-index:30;padding:0;box-shadow:0 2px 10px rgba(0,0,0,0.7);`;
        moveBadge.onclick = (e) => { e.stopPropagation(); selectAndDragSavedText(annIndex); };
        div.appendChild(moveBadge);

        // FLIP: clique no texto faz girar ‚Äî verso em branco estilo Anki
        div.style.perspective = '600px';
        div.style.transformStyle = 'preserve-3d';
        div._flipped = false;

        // Criar camada de verso sobreposta
        const flipBack = document.createElement('div');
        flipBack.style.cssText = `
          position:absolute;inset:0;
          backface-visibility:hidden;-webkit-backface-visibility:hidden;
          transform:rotateY(180deg);
          background:#1a1a1a;border:2px solid #e8ff47;border-radius:6px;
          display:flex;flex-direction:column;justify-content:center;align-items:center;
          padding:12px;box-sizing:border-box;pointer-events:none;
        `;
        flipBack.innerHTML = `<span style="color:#e8ff47;font-family:'Syne',sans-serif;font-weight:700;font-size:13px;opacity:0.6;">‚úè toque em ‚úè para editar</span>`;
        div.appendChild(flipBack);

        // Aplicar backface √† frente
        div.style.backfaceVisibility = 'hidden';
        div.style.webkitBackfaceVisibility = 'hidden';
        div.style.transition = 'transform 0.45s cubic-bezier(0.4,0.2,0.2,1)';

        div.onclick = (e) => {
          e.stopPropagation();
          div._flipped = !div._flipped;
          div.style.transform = div._flipped
            ? `rotate(${ann.rotation||0}deg) rotateY(180deg)`
            : `rotate(${ann.rotation||0}deg) rotateY(0deg)`;
        };
      }

      // ‚îÄ‚îÄ‚îÄ FOTO SALVA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (ann.kind === 'photo') {
        const oRect = overlay.getBoundingClientRect();
        let elW = 200, elH = 300;
        if (ann.customWidth) elW = ann.customWidth.endsWith('%') ? parseFloat(ann.customWidth)/100*oRect.width : parseFloat(ann.customWidth);
        if (ann.customHeight) elH = ann.customHeight.endsWith('%') ? parseFloat(ann.customHeight)/100*oRect.height : parseFloat(ann.customHeight);
        const px = (ann.xPct/100)*oRect.width - elW/2;
        const py = (ann.yPct/100)*oRect.height - elH/2;

        const isSelected = (window._selectedPhotoId === ann._id);
        div.style.cssText = `position:absolute;left:${px}px;top:${py}px;width:${elW}px;height:${elH}px;pointer-events:all;cursor:pointer;z-index:${isSelected ? 35 : 25};border-radius:6px;overflow:visible;box-shadow:0 4px 20px rgba(0,0,0,0.6);${isSelected ? 'outline:3px solid #e8ff47;outline-offset:2px;' : ''}`;

        const imgEl = document.createElement('img');
        imgEl.src = ann.dataUrl;
        imgEl.style.cssText = `width:100%;height:100%;object-fit:cover;border-radius:6px;display:block;pointer-events:none;`;
        div.appendChild(imgEl);

        // üì¶ e ‚úï ‚Äî s√≥ vis√≠veis quando selecionada
        const playlistBadge = document.createElement('button');
        playlistBadge.title = 'Mover para playlist';
        playlistBadge.textContent = 'üì¶';
        playlistBadge.style.cssText = `position:absolute;top:-20px;left:-20px;width:44px;height:44px;border-radius:50%;background:#0a0a0c;border:2px solid rgba(255,255,255,0.7);color:#fff;font-size:20px;align-items:center;justify-content:center;cursor:pointer;pointer-events:all;z-index:30;padding:0;box-shadow:0 2px 10px rgba(0,0,0,0.7);`;
        playlistBadge.style.display = isSelected ? 'flex' : 'none';
        playlistBadge.dataset.badge = '1';
        playlistBadge.onclick = (e) => { e.stopPropagation(); addPhotoToPlaylist(ann._id); };
        playlistBadge.addEventListener('touchstart', (e) => { e.stopPropagation(); }, { passive: false });
        playlistBadge.addEventListener('touchend', (e) => { e.stopPropagation(); e.preventDefault(); addPhotoToPlaylist(ann._id); }, { passive: false });
        div.appendChild(playlistBadge);

        const removeBadge = document.createElement('button');
        removeBadge.title = 'Remover foto';
        removeBadge.textContent = '√ó';
        removeBadge.style.cssText = `position:absolute;top:-20px;right:-20px;width:44px;height:44px;border-radius:50%;background:#ef4444;border:2px solid rgba(255,255,255,0.7);color:#fff;font-size:22px;align-items:center;justify-content:center;cursor:pointer;pointer-events:all;z-index:30;padding:0;box-shadow:0 2px 10px rgba(0,0,0,0.7);`;
        removeBadge.style.display = isSelected ? 'flex' : 'none';
        removeBadge.dataset.badge = '1';
        removeBadge.onclick = (e) => {
          e.stopPropagation();
          window._selectedPhotoId = null;
          const idx = annotations[currentMediaId].findIndex(a => a._id === ann._id);
          if (idx >= 0) { annotations[currentMediaId].splice(idx, 1); buildPauseQueue(); renderSavedArrows(); updateBadge(currentMediaId); }
        };
        div.appendChild(removeBadge);

        // Clique = selecionar (ou desselecionar se j√° era)
        div.onclick = (e) => {
          e.stopPropagation();
          const newId = isSelected ? null : ann._id;
          window._selectedPhotoId = newId;
          // Atualizar todas as fotos no DOM sem re-renderizar
          savedArrowsContainer.querySelectorAll('[data-photo-id]').forEach(el => {
            const elId = el.dataset.photoId;
            const sel = (elId === newId);
            el.style.zIndex = sel ? '35' : '25';
            el.style.outline = sel ? '3px solid #e8ff47' : '';
            el.style.outlineOffset = sel ? '2px' : '';
            el.querySelectorAll('[data-badge]').forEach(b => {
              b.style.display = sel ? 'flex' : 'none';
            });
          });
        };
        div.dataset.photoId = ann._id;
      }

      savedArrowsContainer.appendChild(div);
    });
}

function resetArrowState() {
  if (isImageMode) {
    imgCancelAll();
  } else {
    cancelAll();
  }
  dismissedTimes = new Set();
  internalSeek = false;
  lastAddedTime = null;
  lastSavedAnnId = null;
  nextHighlightLine = 0;
  savedArrowsContainer.innerHTML = '';
  pauseQueue = [];
  pauseQueueIdx = 0;
  lastPausedKey = null;
  _lastAnnotationPauseTime = null;
  rewindToTime = null;
}

// ‚îÄ‚îÄ‚îÄ TEXT PLAYLIST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let textPlaylists = {};

function addPhotoToPlaylist(annId) {
  if (!currentMediaId) return;
  const anns = annotations[currentMediaId] || [];
  const idx = anns.findIndex(a => a._id === annId);
  if (idx < 0) return;
  const ann = anns[idx];
  if (!textPlaylists[currentMediaId]) textPlaylists[currentMediaId] = [];
  textPlaylists[currentMediaId].push({
    kind: 'photo',
    dataUrl: ann.dataUrl,
    customWidth: ann.customWidth,
    customHeight: ann.customHeight,
    time: ann.time,
    savedTrimStart: trimStart,
    savedTrimEnd: isFinite(trimEnd) ? trimEnd : null
  });
  // Remove do v√≠deo
  annotations[currentMediaId].splice(idx, 1);
  // Limpar dismissedTimes do tempo original para que o pause da playlist dispare
  if (ann.time != null) {
    for (const key of [...dismissedTimes]) {
      let keyTime = parseFloat(key);
      if (isNaN(keyTime)) { const m = key.match(/_(\d+\.?\d*)(?:_\d+\.?\d*)?$/); if (m) keyTime = parseFloat(m[1]); }
      if (!isNaN(keyTime) && Math.abs(keyTime - ann.time) < 0.3) dismissedTimes.delete(key);
    }
  }
  buildPauseQueue();
  renderSavedArrows(video.currentTime);
  renderAnnotationsList();
  updateBadge(currentMediaId);
  renderTextPlaylist();
  showToast('üì¶ Foto movida para a playlist', 'success');
}

function addTextToPlaylist() {
  if (!currentMediaId) return;

  // Se h√° uma foto selecionada (amarelo), mover ela para a playlist
  if (window._selectedPhotoId) {
    addPhotoToPlaylist(window._selectedPhotoId);
    window._selectedPhotoId = null;
    return;
  }

  let text = '', fontSize = 15, bgColor = 'rgba(232,255,71,0.92)', customWidth = null, customHeight = null, time = null;

  if (textMode && pendingTextContent) {
    text = pendingTextContent;
    fontSize = textFontSize;
    bgColor = TEXT_BG_COLORS[textBgColorIdx].value;
    customWidth = textEl.style.width || null;
    customHeight = textEl.style.height || null;
    time = pendingTime || video.currentTime;
    cancelAll();
  } else {
    const anns = annotations[currentMediaId] || [];
    const found = [...anns].map((a, i) => ({ a, i })).reverse().find(({ a }) => a.kind === 'text');
    if (!found) { showToast('Nenhum texto para adicionar.', 'error'); return; }
    const { a: textAnn, i: idx } = found;
    text = textAnn.text || '';
    fontSize = textAnn.fontSize || 15;
    bgColor = textAnn.bgColor || 'rgba(232,255,71,0.92)';
    customWidth = textAnn.customWidth || null;
    customHeight = textAnn.customHeight || null;
    time = textAnn.time;
    annotations[currentMediaId].splice(idx, 1);
    buildPauseQueue();
    renderSavedArrows(video.currentTime);
    renderAnnotationsList();
    updateBadge(currentMediaId);
  }

  if (!text) { showToast('Texto vazio.', 'error'); return; }
  if (!textPlaylists[currentMediaId]) textPlaylists[currentMediaId] = [];
  textPlaylists[currentMediaId].push({ text, fontSize, bgColor, customWidth, customHeight, time, savedTrimStart: trimStart, savedTrimEnd: isFinite(trimEnd) ? trimEnd : null });
  // Limpar dismissedTimes do tempo original para que o pause da playlist dispare
  if (time != null) {
    for (const key of [...dismissedTimes]) {
      let keyTime = parseFloat(key);
      if (isNaN(keyTime)) { const m = key.match(/_(\d+\.?\d*)(?:_\d+\.?\d*)?$/); if (m) keyTime = parseFloat(m[1]); }
      if (!isNaN(keyTime) && Math.abs(keyTime - time) < 0.3) dismissedTimes.delete(key);
    }
  }
  buildPauseQueue();
  renderTextPlaylist();
  showToast('üì¶ Movido para a playlist', 'success');
}

function jumpToPlaylistItem(idx) {
  const item = (textPlaylists[currentMediaId] || [])[idx];
  if (!item || item.time == null) return;

  // Restaurar Trim A e Trim B salvos
  trimStart = item.savedTrimStart != null ? item.savedTrimStart : 0;
  trimEnd   = item.savedTrimEnd   != null ? item.savedTrimEnd   : Infinity;
  updateTrimVisuals();

  // Zerar tudo ‚Äî come√ßa do in√≠cio do trim
  dismissedTimes.clear();
  pauseQueueIdx = 0;
  selectedAnnIndex = null;
  lastPausedKey = null;
  _lastAnnotationPauseTime = null;
  rewindToTime = null;

  // Seek para o TrimA (in√≠cio)
  video.pause();
  internalSeek = true;
  video.currentTime = trimStart;

  showToast('‚è± Trim restaurado', 'success');
}

function restoreTrimOnly(idx) {
  const item = (textPlaylists[currentMediaId] || [])[idx];
  if (!item) return;
  trimStart = item.savedTrimStart != null ? item.savedTrimStart : 0;
  trimEnd   = item.savedTrimEnd   != null ? item.savedTrimEnd   : Infinity;
  updateTrimVisuals();
  // Seek preciso para o trimStart para evitar o delay de ~300ms ao dar play
  video.pause();
  internalSeek = true;
  video.currentTime = trimStart;
  dismissedTimes.clear();
  pauseQueueIdx = 0;
  lastPausedKey = null;
  rewindOnNextPlay = false;
  rewindToTime = null;
}

let _playlistScrollToBottom = false; // flag: rolar pro fundo s√≥ ao adicionar item

function renderTextPlaylist() {
  const wrapper = document.getElementById('textPlaylistWrapper');
  const container = document.getElementById('textPlaylist');
  const emptyMsg = document.getElementById('textPlaylistEmpty');
  const items = (currentMediaId && textPlaylists[currentMediaId]) || [];

  const videoContainer = document.getElementById('videoContainer');
  const isVideo = videoContainer.style.display !== 'none';
  if (!isVideo || !currentMediaId) {
    wrapper.classList.remove('visible');
    return;
  }

  wrapper.classList.add('visible');
  const _savedScroll = _playlistScrollToBottom ? null : container.scrollTop;
  container.innerHTML = '';

  if (items.length === 0) {
    emptyMsg.style.display = 'block';
    return;
  }

  emptyMsg.style.display = 'none';

  items.forEach((item, idx) => {
    const outer = document.createElement('div');
    outer.className = 'playlist-item';
    outer.style.cursor = 'pointer';
    outer.title = item.savedTrimStart != null ? `Trim A: ${formatShortTime(item.savedTrimStart)} | Trim B: ${item.savedTrimEnd != null ? formatShortTime(item.savedTrimEnd) : 'fim'}` : '';
    // Fotos e textos: flip card cuida do clique
    const isActive = lastPausedKey === `playlist_${idx}_${item.time}`;

    if (item.kind === 'photo') {
      // FLIP CARD ‚Äî frente = foto, verso = texto edit√°vel
      const scene = document.createElement('div');
      scene.className = 'playlist-card-scene';

      const card = document.createElement('div');
      card.className = 'playlist-card' + (item._flipped ? ' flipped' : '');

      // ‚îÄ‚îÄ FRENTE: foto ‚îÄ‚îÄ
      const front = document.createElement('div');
      front.className = 'playlist-card-face playlist-card-front';
      front.style.cssText = `border-radius:6px;overflow:hidden;box-shadow:0 4px 16px rgba(0,0,0,0.5);${isActive ? 'outline:3px solid #3b82f6;outline-offset:2px;' : ''}`;
      const img = document.createElement('img');
      img.src = item.dataUrl;
      img.style.cssText = `width:100%;display:block;border-radius:6px;`;
      front.appendChild(img);
      card.appendChild(front);

      // ‚îÄ‚îÄ VERSO: texto ‚îÄ‚îÄ
      const back = document.createElement('div');
      back.className = 'playlist-card-face playlist-card-back';
      const photoBackLabel = document.createElement('div');
      photoBackLabel.style.cssText = `padding:8px 10px;color:#e8ff47;font-family:'Syne',sans-serif;font-weight:700;font-size:14px;white-space:pre-wrap;overflow-wrap:break-word;min-height:60px;flex:1;`;
      photoBackLabel.textContent = item.backText || '‚Äî';
      back.appendChild(photoBackLabel);
      card.appendChild(back);

      // Spacer baseado na foto (altura fixa m√≠nima)
      const spacer = document.createElement('div');
      spacer.className = 'playlist-card-back-spacer';
      spacer.style.cssText = `visibility:hidden;pointer-events:none;min-height:60px;`;
      spacer.textContent = item.backText || '‚Äî';
      card.appendChild(spacer);

      // Long press na frente = fullscreen da foto
      let _photoLongPressTimer;
      let _photoLongPressed = false;
      const startPhotoLongPress = (e) => {
        _photoLongPressed = false;
        _photoLongPressTimer = setTimeout(() => {
          _photoLongPressed = true;
          const fsOverlay = document.createElement('div');
          fsOverlay.style.cssText = `position:fixed;inset:0;background:rgba(0,0,0,0.95);z-index:9999;display:flex;align-items:center;justify-content:center;`;
          const fsImg = document.createElement('img');
          fsImg.src = item.dataUrl;
          fsImg.style.cssText = `max-width:95vw;max-height:90vh;object-fit:contain;border-radius:8px;`;
          const fsClose = document.createElement('button');
          fsClose.textContent = '‚úï';
          fsClose.style.cssText = `position:absolute;top:20px;right:20px;background:rgba(255,255,255,0.15);border:2px solid #fff;color:#fff;width:44px;height:44px;border-radius:50%;font-size:20px;cursor:pointer;display:flex;align-items:center;justify-content:center;`;
          fsClose.onclick = () => document.body.removeChild(fsOverlay);
          fsOverlay.appendChild(fsImg);
          fsOverlay.appendChild(fsClose);
          document.body.appendChild(fsOverlay);
        }, 500);
      };
      const cancelPhotoLongPress = () => clearTimeout(_photoLongPressTimer);
      front.addEventListener('mousedown', startPhotoLongPress);
      front.addEventListener('touchstart', startPhotoLongPress, { passive: true });
      front.addEventListener('mouseup', cancelPhotoLongPress);
      front.addEventListener('mouseleave', cancelPhotoLongPress);
      front.addEventListener('touchend', cancelPhotoLongPress);
      front.addEventListener('touchmove', cancelPhotoLongPress, { passive: true });
      front.addEventListener('contextmenu', (e) => e.preventDefault());

      // Toque = vira (s√≥ se n√£o foi long press)
      card.onclick = (e) => {
        e.stopPropagation();
        if (_photoLongPressed) { _photoLongPressed = false; return; }
        item._flipped = !item._flipped;
        textPlaylists[currentMediaId][idx]._flipped = item._flipped;
        card.classList.toggle('flipped', item._flipped);
        if (!item._flipped) {
          const pl = document.getElementById('textPlaylist');
          const savedScroll = pl ? pl.scrollTop : 0;
          restoreTrimOnly(idx);
          if (pl) {
            pl.scrollTop = savedScroll;
            setTimeout(() => { pl.scrollTop = savedScroll; }, 50);
            setTimeout(() => { pl.scrollTop = savedScroll; }, 150);
          }
        }
      };

      // ‚úè bot√£o editar verso (superior esquerdo)
      const editBtn = document.createElement('button');
      editBtn.innerHTML = '‚úè';
      editBtn.title = 'Editar verso';
      editBtn.style.cssText = `position:absolute;top:-16px;left:-16px;width:34px;height:34px;border-radius:50%;background:#0a0a0c;border:2px solid #e8ff47;color:#e8ff47;font-size:15px;display:flex;align-items:center;justify-content:center;cursor:pointer;pointer-events:all;z-index:20;padding:0;`;
      editBtn.onclick = (e) => {
        e.stopPropagation();
        const current = item.backText || '';
        const popup = document.getElementById('textPopup');
        const input = document.getElementById('textPopupInput');
        input.value = current;
        window._playlistEditConfirmOverride = (newVal) => {
          textPlaylists[currentMediaId][idx].backText = newVal;
          item.backText = newVal;
          photoBackLabel.textContent = newVal || '‚Äî';
          spacer.textContent = newVal || '‚Äî';
          window._playlistEditConfirmOverride = null;
        };
        popup.classList.add('active');
        setTimeout(() => input.focus(), 100);
      };

      scene.style.position = 'relative';
      scene.appendChild(card);
      scene.appendChild(editBtn);
      outer.appendChild(scene);
    } else {
      // FLIP CARD estilo Anki
      const scene = document.createElement('div');
      scene.className = 'playlist-card-scene';

      const card = document.createElement('div');
      card.className = 'playlist-card' + (item._flipped ? ' flipped' : '');

      // ‚îÄ‚îÄ FRENTE ‚îÄ‚îÄ
      const front = document.createElement('div');
      front.className = 'playlist-card-face playlist-card-front';
      front.style.cssText = `background:${item.bgColor};color:#0a0a0c;font-family:'Syne',sans-serif;font-weight:700;font-size:${item.fontSize}px;padding:8px 10px;border-radius:6px;white-space:pre-wrap;overflow-wrap:break-word;box-shadow:0 4px 16px rgba(0,0,0,0.5);box-sizing:border-box;min-height:44px;${isActive ? 'outline:3px solid #3b82f6;outline-offset:2px;' : ''}`;
      front.textContent = item.text;
      card.appendChild(front);

      // ‚îÄ‚îÄ VERSO ‚îÄ‚îÄ
      const back = document.createElement('div');
      back.className = 'playlist-card-face playlist-card-back';

      const backLabel = document.createElement('div');
      backLabel.style.cssText = `padding:8px 10px;color:#e8ff47;font-family:'Syne',sans-serif;font-weight:700;font-size:${item.fontSize}px;white-space:pre-wrap;overflow-wrap:break-word;min-height:44px;flex:0 0 auto;`;
      backLabel.textContent = item.backText || '‚Äî';
      back.appendChild(backLabel);

      // ‚îÄ‚îÄ SUB-CARDS ‚îÄ‚îÄ
      if (!item.subCards) item.subCards = [];
      const subcardList = document.createElement('div');
      subcardList.className = 'subcard-list';

      function renderSubCards() {
        subcardList.innerHTML = '';
        item.subCards.forEach((sc, si) => {
          const scScene = document.createElement('div');
          scScene.className = 'subcard-scene';

          const scCard = document.createElement('div');
          scCard.className = 'subcard' + (sc._flipped ? ' flipped' : '');

          const scFront = document.createElement('div');
          scFront.className = 'subcard-face subcard-front';
          if (sc.frontImg) {
            const fi = document.createElement('img');
            fi.src = sc.frontImg;
            fi.style.cssText = 'max-width:100%;max-height:80px;border-radius:4px;object-fit:contain;pointer-events:none;';
            scFront.appendChild(fi);
          } else {
            scFront.textContent = sc.front || '...';
          }

          const scBack = document.createElement('div');
          scBack.className = 'subcard-face subcard-back';
          if (sc.backImg) {
            const bi = document.createElement('img');
            bi.src = sc.backImg;
            bi.style.cssText = 'max-width:100%;max-height:80px;border-radius:4px;object-fit:contain;pointer-events:none;';
            scBack.appendChild(bi);
          } else {
            scBack.textContent = sc.back || '‚Äî';
          }

          scCard.appendChild(scFront);
          scCard.appendChild(scBack);

          // pointer-events: desativa face oculta para evitar cliques fantasmas
          function updateScFaces() {
            scFront.style.pointerEvents = sc._flipped ? 'none' : 'all';
            scBack.style.pointerEvents  = sc._flipped ? 'all'  : 'none';
          }
          updateScFaces();

          // Clique no card = vira
          scCard.onclick = (e) => {
            e.stopPropagation();
            sc._flipped = !sc._flipped;
            scCard.classList.toggle('flipped', sc._flipped);
            updateScFaces();
          };

          // Clique longo = editar o lado vis√≠vel
          let longPressTimer;
          const openSubcardEditor = (sc, isBack) => {
            const input = document.getElementById('textPopupInput');
            input.value = isBack ? (sc.back || '') : (sc.front || '');
            const existingImg = isBack ? sc.backImg : sc.frontImg;
            if (existingImg) {
              _subcardPendingImg = existingImg;
              document.getElementById('subcardImgPreviewEl').src = existingImg;
              document.getElementById('subcardImgPreview').style.display = 'block';
            }
            showSubcardImgBtn(true);
            window._playlistEditConfirmOverride = (newVal) => {
              if (isBack) {
                if (_subcardPendingImg) { sc.backImg = _subcardPendingImg; sc.back = ''; }
                else { sc.back = newVal; delete sc.backImg; }
              } else {
                if (_subcardPendingImg) { sc.frontImg = _subcardPendingImg; sc.front = ''; }
                else { sc.front = newVal; delete sc.frontImg; }
              }
              showSubcardImgBtn(false);
              window._playlistEditConfirmOverride = null;
              renderSubCards();
            };
            document.getElementById('textPopup').classList.add('active');
            setTimeout(() => input.focus(), 100);
          };

          const startLongPress = (e) => {
            e.stopPropagation();
            longPressTimer = setTimeout(() => {
              const isBack = sc._flipped;
              const existingImg = isBack ? sc.backImg : sc.frontImg;

              if (existingImg) {
                // Mostrar fullscreen primeiro, depois abre editor ao fechar
                const overlay = document.createElement('div');
                overlay.style.cssText = `position:fixed;inset:0;background:rgba(0,0,0,0.95);z-index:9999;display:flex;align-items:center;justify-content:center;`;
                const img = document.createElement('img');
                img.src = existingImg;
                img.style.cssText = `max-width:95vw;max-height:90vh;object-fit:contain;border-radius:8px;`;
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '‚úï';
                closeBtn.style.cssText = `position:absolute;top:20px;right:20px;background:rgba(255,255,255,0.15);border:2px solid #fff;color:#fff;width:44px;height:44px;border-radius:50%;font-size:20px;cursor:pointer;display:flex;align-items:center;justify-content:center;`;
                closeBtn.onclick = () => {
                  document.body.removeChild(overlay);
                  openSubcardEditor(sc, isBack);
                };
                overlay.appendChild(img);
                overlay.appendChild(closeBtn);
                document.body.appendChild(overlay);
              } else {
                openSubcardEditor(sc, isBack);
              }
            }, 500);
          };
          const cancelLongPress = () => clearTimeout(longPressTimer);
          scCard.addEventListener('mousedown', startLongPress);
          scCard.addEventListener('touchstart', startLongPress, { passive: true });
          scCard.addEventListener('mouseup', cancelLongPress);
          scCard.addEventListener('mouseleave', cancelLongPress);
          scCard.addEventListener('touchend', cancelLongPress);
          scCard.addEventListener('touchmove', cancelLongPress, { passive: true });
          scCard.addEventListener('contextmenu', (e) => e.preventDefault());

          // Bot√£o remover ‚Äî s√≥ na frente, bloqueado se virado
          const scRemove = document.createElement('button');
          scRemove.className = 'subcard-remove';
          scRemove.textContent = '√ó';
          scRemove.title = 'Remover';
          scRemove.onclick = (e) => {
            e.stopPropagation();
            if (sc._flipped) return;
            item.subCards.splice(si, 1);
            textPlaylists[currentMediaId][idx].subCards = item.subCards;
            renderSubCards();
            updateSubCardSpacer();
          };
          scFront.appendChild(scRemove);

          scScene.appendChild(scCard);
          subcardList.appendChild(scScene);
        });

        // Bot√£o "+"
        const addBtn = document.createElement('button');
        addBtn.className = 'subcard-add-btn';
        addBtn.textContent = '+';
        addBtn.onclick = (e) => {
          e.stopPropagation();
          const popup = document.getElementById('textPopup');
          const input = document.getElementById('textPopupInput');
          const title = popup.querySelector('h3');
          const origTitle = title ? title.textContent : '';

          // PASSO 1: pede a frente
          input.value = '';
          if (title) title.textContent = '‚úèÔ∏è Frente do sub-card';
          showSubcardImgBtn(true);
          popup.classList.add('active');
          setTimeout(() => input.focus(), 100);

          window._playlistEditConfirmOverride = (frontVal) => {
            window._playlistEditConfirmOverride = null;
            const frontImg = _subcardPendingImg || null;
            const frontText = frontImg ? '' : (frontVal.trim() || '...');
            showSubcardImgBtn(false);
            if (!frontImg && !frontVal.trim()) { if (title) title.textContent = origTitle; return; }

            // PASSO 2: pede o verso
            input.value = '';
            if (title) title.textContent = '‚Ü© Verso do sub-card';
            showSubcardImgBtn(true);
            popup.classList.add('active');
            setTimeout(() => input.focus(), 100);

            window._playlistEditConfirmOverride = (backVal) => {
              window._playlistEditConfirmOverride = null;
              if (title) title.textContent = origTitle;
              const backImg = _subcardPendingImg || null;
              const backText = backImg ? '' : (backVal.trim() || '‚Äî');
              showSubcardImgBtn(false);
              const newSc = { front: frontText, back: backText, _flipped: false };
              if (frontImg) newSc.frontImg = frontImg;
              if (backImg) newSc.backImg = backImg;
              item.subCards.push(newSc);
              textPlaylists[currentMediaId][idx].subCards = item.subCards;
              _playlistScrollToBottom = true;
              renderSubCards();
              updateSubCardSpacer();
            };
          };
        };
        subcardList.appendChild(addBtn);
      }

      renderSubCards();
      back.appendChild(subcardList);
      card.appendChild(back);

      // Spacer: inclui texto de resposta + sub-cards
      const spacer = document.createElement('div');
      spacer.className = 'playlist-card-back-spacer';
      spacer.style.fontSize = item.fontSize + 'px';
      spacer.textContent = item.backText || '‚Äî';
      // Altura din√¢mica: ser√° atualizada quando sub-cards mudam
      function updateSubCardSpacer() {
        // Medir altura real do verso e aplicar no spacer
        requestAnimationFrame(() => {
          const backH = back.scrollHeight;
          spacer.style.minHeight = (backH > 0 ? backH : 60) + 'px';
        });
      }
      updateSubCardSpacer();
      card.appendChild(spacer);

      // ‚îÄ‚îÄ Toque no card = vira ‚îÄ‚îÄ
      card.onclick = (e) => {
        e.stopPropagation();
        item._flipped = !item._flipped;
        textPlaylists[currentMediaId][idx]._flipped = item._flipped;
        card.classList.toggle('flipped', item._flipped);
        if (!item._flipped) {
          const pl = document.getElementById('textPlaylist');
          const savedScroll = pl ? pl.scrollTop : 0;
          restoreTrimOnly(idx);
          if (pl) {
            pl.scrollTop = savedScroll;
            setTimeout(() => { pl.scrollTop = savedScroll; }, 50);
            setTimeout(() => { pl.scrollTop = savedScroll; }, 150);
          }
        }
      };

      // ‚îÄ‚îÄ Bot√£o ‚úè canto superior esquerdo ‚Äî edita o lado vis√≠vel ‚îÄ‚îÄ
      const editBtn = document.createElement('button');
      editBtn.innerHTML = '‚úè';
      editBtn.title = 'Editar este lado';
      editBtn.style.cssText = `position:absolute;top:-16px;left:-16px;width:34px;height:34px;border-radius:50%;background:#0a0a0c;border:2px solid #e8ff47;color:#e8ff47;font-size:15px;display:flex;align-items:center;justify-content:center;cursor:pointer;pointer-events:all;z-index:20;padding:0;`;
      editBtn.onclick = (e) => {
        e.stopPropagation();
        const isBack = item._flipped;
        const current = isBack ? (item.backText || '') : item.text;
        // Usar o mesmo popup grande dos textos do v√≠deo
        const popup = document.getElementById('textPopup');
        const input = document.getElementById('textPopupInput');
        input.value = current;
        window._playlistEditConfirmOverride = (newVal) => {
          if (isBack) {
            textPlaylists[currentMediaId][idx].backText = newVal;
            item.backText = newVal;
            backLabel.textContent = newVal || '‚Äî';
          } else {
            textPlaylists[currentMediaId][idx].text = newVal;
            item.text = newVal;
            front.textContent = newVal;
          }
          window._playlistEditConfirmOverride = null;
        };
        popup.classList.add('active');
        setTimeout(() => input.focus(), 100);
      };

      scene.style.position = 'relative';
      scene.appendChild(card);
      scene.appendChild(editBtn);
      outer.appendChild(scene);
    }

    const removeBtn = document.createElement('button');
    removeBtn.className = 'playlist-item-remove';
    removeBtn.textContent = '√ó';
    removeBtn.title = 'Remover da playlist';
    removeBtn.onclick = (e) => {
      e.stopPropagation();
      textPlaylists[currentMediaId].splice(idx, 1);
      renderTextPlaylist();
    };

    outer.appendChild(removeBtn);
    container.appendChild(outer);
  });

  // Ir pro fundo s√≥ se foi pedido explicitamente (novo item), sen√£o restaurar posi√ß√£o
  if (_playlistScrollToBottom) {
    container.scrollTop = container.scrollHeight;
    _playlistScrollToBottom = false;
  } else {
    container.scrollTop = _savedScroll;
  }
}

// ‚îÄ‚îÄ‚îÄ PLAYLIST RESIZE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(function() {
  let resizing = false;
  let startX, startY, startW, startH;

  function onDown(e) {
    e.preventDefault();
    e.stopPropagation();
    resizing = true;
    const client = e.touches ? e.touches[0] : e;
    startX = client.clientX;
    startY = client.clientY;
    const wrapper = document.getElementById('textPlaylistWrapper');
    startW = wrapper.offsetWidth;
    startH = wrapper.offsetHeight;
    document.addEventListener('mousemove', onMove);
    document.addEventListener('touchmove', onMove, { passive: false });
    document.addEventListener('mouseup', onUp);
    document.addEventListener('touchend', onUp);
  }

  function onMove(e) {
    if (!resizing) return;
    if (e.cancelable) e.preventDefault();
    const client = e.touches ? e.touches[0] : e;
    const dx = startX - client.clientX; // arrastar esquerda = mais largo
    const dy = startY - client.clientY; // arrastar cima = mais alto
    const wrapper = document.getElementById('textPlaylistWrapper');
    const newW = Math.max(60, startW + dx);
    const newH = Math.max(80, startH + dy);
    wrapper.style.width = newW + 'px';
    wrapper.style.height = newH + 'px';
  }

  function onUp() {
    resizing = false;
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('touchmove', onMove);
    document.removeEventListener('mouseup', onUp);
    document.removeEventListener('touchend', onUp);
  }

  document.addEventListener('DOMContentLoaded', () => {
    const handle = document.getElementById('textPlaylistResizeHandle');
    if (handle) {
      handle.addEventListener('mousedown', onDown);
      handle.addEventListener('touchstart', onDown, { passive: false });
    }
  });
})();

// ‚îÄ‚îÄ‚îÄ PHOTO ANNOTATIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let photoMode = false;
let photoXPct = 50, photoYPct = 40;
let photoW = 200, photoH = 300;
let photoDragOffX = 0, photoDragOffY = 0;
let pendingPhotoDataUrl = null;

const photoEl = document.getElementById('annotationPhotoEl');
const photoImg = document.getElementById('annotationPhotoImg');
const photoResizeHandle = document.getElementById('photoResizeHandle');

function activatePhotoMode(event) {
  const file = event.target.files && event.target.files[0];
  event.target.value = '';
  if (!file || !file.type.startsWith('image/')) return;
  if (arrowMode || textMode || photoMode) cancelAll();

  const reader = new FileReader();
  reader.onload = (e) => {
    pendingPhotoDataUrl = e.target.result;
    photoImg.src = pendingPhotoDataUrl;
    photoMode = true;
    activeMode = 'photo';
    pendingTime = isImageMode ? 0 : safeAnnotationTime(video.currentTime);
    if (!isImageMode) video.pause();

    // Place in center of overlay
    const oRect = overlay.getBoundingClientRect();
    photoW = 200; photoH = 300;
    photoXPct = 50; photoYPct = 50;
    placePhoto(photoXPct, photoYPct);
    photoEl.style.display = 'block';

    // Show done button
    doneBtn.style.display = 'flex';
    document.getElementById('photoBtn').classList.add('active');
  };
  reader.readAsDataURL(file);
}

function placePhoto(xPct, yPct) {
  const oRect = overlay.getBoundingClientRect();
  if (!oRect.width) return;
  const px = (xPct / 100) * oRect.width - photoW / 2;
  const py = (yPct / 100) * oRect.height - photoH / 2;
  photoEl.style.left = px + 'px';
  photoEl.style.top = py + 'px';
  photoEl.style.width = photoW + 'px';
  photoEl.style.height = photoH + 'px';
  photoXPct = xPct;
  photoYPct = yPct;
}

function savePhotoAnnotation() {
  if (!pendingPhotoDataUrl || !currentMediaId || pendingTime === null) return;
  const savedTime = pendingTime;
  // Vai direto pro üì¶ move sem aparecer no v√≠deo
  if (!textPlaylists[currentMediaId]) textPlaylists[currentMediaId] = [];
  textPlaylists[currentMediaId].push({
    kind: 'photo',
    dataUrl: pendingPhotoDataUrl,
    backText: '',
    customWidth: null,
    customHeight: null,
    time: savedTime,
    savedTrimStart: trimStart,
    savedTrimEnd: isFinite(trimEnd) ? trimEnd : null,
    subCards: [],
    _flipped: false
  });
  cancelAll();
  buildPauseQueue();
  _playlistScrollToBottom = true;
  renderTextPlaylist();
  showToast('üì¶ Foto adicionada ao move', 'success');
}

// Drag photo
(function() {
  let dragging = false;
  let startX, startY, startLeft, startTop;

  function onDown(e) {
    if (!photoMode) return;
    if (e.target === photoResizeHandle || photoResizeHandle.contains(e.target)) return;
    e.preventDefault();
    dragging = true;
    const client = e.touches ? e.touches[0] : e;
    startX = client.clientX; startY = client.clientY;
    startLeft = parseFloat(photoEl.style.left) || 0;
    startTop = parseFloat(photoEl.style.top) || 0;
    document.addEventListener('mousemove', onMove);
    document.addEventListener('touchmove', onMove, { passive: false });
    document.addEventListener('mouseup', onUp);
    document.addEventListener('touchend', onUp);
  }
  function onMove(e) {
    if (!dragging) return;
    if (e.cancelable) e.preventDefault();
    const client = e.touches ? e.touches[0] : e;
    const dx = client.clientX - startX;
    const dy = client.clientY - startY;
    const newLeft = startLeft + dx;
    const newTop = startTop + dy;
    photoEl.style.left = newLeft + 'px';
    photoEl.style.top = newTop + 'px';
    const oRect = overlay.getBoundingClientRect();
    if (oRect.width) {
      photoXPct = ((newLeft + photoW / 2) / oRect.width) * 100;
      photoYPct = ((newTop + photoH / 2) / oRect.height) * 100;
    }
  }
  function onUp() {
    dragging = false;
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('touchmove', onMove);
    document.removeEventListener('mouseup', onUp);
    document.removeEventListener('touchend', onUp);
  }
  photoEl.addEventListener('mousedown', onDown);
  photoEl.addEventListener('touchstart', onDown, { passive: false });
})();

// Resize photo
(function() {
  let resizing = false;
  let startX, startY, startW, startH;
  function onDown(e) {
    e.preventDefault(); e.stopPropagation();
    resizing = true;
    const client = e.touches ? e.touches[0] : e;
    startX = client.clientX; startY = client.clientY;
    startW = photoW; startH = photoH;
    document.addEventListener('mousemove', onMove);
    document.addEventListener('touchmove', onMove, { passive: false });
    document.addEventListener('mouseup', onUp);
    document.addEventListener('touchend', onUp);
  }
  function onMove(e) {
    if (!resizing) return;
    if (e.cancelable) e.preventDefault();
    const client = e.touches ? e.touches[0] : e;
    photoW = Math.max(40, startW + (client.clientX - startX));
    photoH = Math.max(40, startH + (client.clientY - startY));
    photoEl.style.width = photoW + 'px';
    photoEl.style.height = photoH + 'px';
  }
  function onUp() {
    resizing = false;
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('touchmove', onMove);
    document.removeEventListener('mouseup', onUp);
    document.removeEventListener('touchend', onUp);
  }
  photoResizeHandle.addEventListener('mousedown', onDown);
  photoResizeHandle.addEventListener('touchstart', onDown, { passive: false });
})();

// ‚îÄ‚îÄ‚îÄ LINE HIGHLIGHT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function addLineHighlight() {
  if (arrowMode || textMode) {
    showToast('Conclua ou desfa√ßa a anota√ß√£o antes de continuar.', 'error');
    return;
  }
  if (!currentMediaId) return;
  const anns = annotations[currentMediaId] || [];
  const textAnn = anns.find(a => a.kind === 'text');
  if (!textAnn) {
    showToast('Adicione um texto primeiro.', 'error');
    return;
  }
  const totalLines = (textAnn.text || '').split('\n').length;
  const lineIndex = nextHighlightLine % totalLines;
  annotations[currentMediaId].push({
    kind: 'line_highlight',
    time: video.currentTime,
    lineIndex,
      _id: _newAnnId()
    });
  lastSavedAnnId = annotations[currentMediaId][annotations[currentMediaId].length - 1]._id;
  annotations[currentMediaId].sort((a, b) => a.time - b.time);
  dismissedTimes.add(video.currentTime);
  nextHighlightLine = (nextHighlightLine + 1) % totalLines;
  buildPauseQueue();
  renderSavedArrows(video.currentTime);
  renderAnnotationsList();
  updateBadge(currentMediaId);
  showToast(`‚Ü≥ Linha ${lineIndex + 1} marcada`, 'success');
}

// ‚îÄ‚îÄ‚îÄ ANNOTATIONS LIST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderAnnotationsList() {
  const panel = document.getElementById('annotationsPanel');
  const anns = annotations[currentMediaId] || [];
  panel.innerHTML = `<h4>Setas (${anns.length})</h4>`;

  if (anns.length === 0) {
    panel.innerHTML += `<p style="font-size:12px;color:var(--muted);text-align:center;padding:16px 0">Nenhuma seta adicionada</p>`;
    return;
  }

  anns.forEach((ann, i) => {
    const div = document.createElement('div');
    div.className = 'ann-item';
    const icon = (!ann.kind || ann.kind === 'arrow') ? '‚Üó' : ann.kind === 'line_highlight' ? '‚Ü≥' : '‚úèÔ∏è';
    const label = (!ann.kind || ann.kind === 'arrow') ? `Seta ${i+1}` : ann.kind === 'line_highlight' ? `Linha ${ann.lineIndex + 1}` : `Texto ${i+1}`;
    const editCount = (ann.edits && ann.edits.length > 1) ? ` <span style="font-size:10px;color:var(--accent);margin-left:4px;">(${ann.edits.length} vers√µes)</span>` : '';
    div.innerHTML = `
      <span>${icon} <strong>${label}</strong>${editCount}</span>
      <span class="ann-time">${formatTime(ann.time)}</span>
    `;
    div.onclick = () => {
      video.currentTime = ann.time;
      video.pause();
      dismissedTimes.add(ann.time);
    };
    if (ann.kind === 'text' && !isImageMode) {
      const editBtn = document.createElement('button');
      editBtn.className = 'ann-delete';
      editBtn.title = 'Editar texto';
      editBtn.textContent = '‚úè';
      editBtn.style.cssText = 'color:var(--accent);border-color:var(--accent);margin-right:4px;';
      editBtn.onclick = (e) => { e.stopPropagation(); editSavedTextById(ann._id, e); };
      div.appendChild(editBtn);
    }
    const delBtn = document.createElement('button');
    delBtn.className = 'ann-delete';
    delBtn.title = 'Remover';
    delBtn.textContent = '√ó';
    delBtn.onclick = (e) => { e.stopPropagation(); deleteAnnotation(i, e); };
    div.appendChild(delBtn);
    panel.appendChild(div);
  });
}

function deleteAnnotation(index, e) {
  e.stopPropagation();
  annotations[currentMediaId].splice(index, 1);
  renderSavedArrows();
  renderAnnotationsList();
  updateBadge(currentMediaId);
  renderSkipZones();
}

function selectAndDragSavedText(index) {
  const ann = (annotations[currentMediaId] || [])[index];
  if (!ann || ann.kind !== 'text') return;
  // Preserve the edits history so it survives drag/resize
  window._draggingAnnEdits = ann.edits ? JSON.parse(JSON.stringify(ann.edits)) : null;
  window._draggingAnnBgColor = ann.bgColor || null;
  annotations[currentMediaId].splice(index, 1);
  dismissedTimes.delete(ann.time);
  selectedAnnIndex = null;
  renderSavedArrows();
  if (!isImageMode) { renderAnnotationsList(); }
  updateBadge(currentMediaId);
  pendingTime = isImageMode ? 0 : ann.time;
  // Use the text version visible at current video time
  let dragText = ann.text || '';
  if (!isImageMode && ann.edits && ann.edits.length > 0) {
    const t = video.currentTime;
    for (const edit of ann.edits) { if (edit.time <= t + 0.05) dragText = edit.text; }
  }
  pendingTextContent = dragText;
  textXPct = ann.xPct; textYPct = ann.yPct;
  textRotation = ann.rotation || 0;
  textFontSize = ann.fontSize || 15;
  textEl.childNodes[0].textContent = pendingTextContent;
  textEl.style.fontSize = textFontSize + 'px';
  if (ann.customWidth) {
    const oRect = overlay.getBoundingClientRect();
    textEl.style.width = ann.customWidth.endsWith('%') ? (parseFloat(ann.customWidth) / 100 * oRect.width) + 'px' : ann.customWidth;
    textEl.style.maxWidth = 'none';
  } else { textEl.style.width = ''; textEl.style.maxWidth = ''; }
  textEl.style.height = ann.customHeight || '';
  textEl.style.display = 'block';
  textEl.style.background = TEXT_BG_COLORS[textBgColorIdx].value;
  placeText(textXPct, textYPct);
  textMode = true;
  activeMode = 'text';
  if (isImageMode) {
    document.getElementById('imgTextBtn').classList.add('active');
    document.getElementById('imgDoneBtn').style.display = 'flex';
    document.getElementById('imgFontMinusBtn').style.display = 'flex'; document.getElementById('imgFontSizeDisplay').style.display = 'inline-block'; document.getElementById('imgFontSizeDisplay').textContent = textFontSize + 'px';
    document.getElementById('imgFontPlusBtn').style.display = 'flex';
      { const _ib=document.getElementById('imgBgColorBtn'); const _id=document.getElementById('imgBgColorDot'); if(_ib)_ib.style.display='flex'; if(_id)_id.style.background=TEXT_BG_COLORS[textBgColorIdx].dot; }
    document.getElementById('imgEditTextBtn').style.opacity = '1';
    document.getElementById('imgEditTextBtn').style.cursor = 'pointer';
  } else {
    textBtn.classList.add('active');
    doneBtn.style.display = 'flex';
    document.getElementById('fontMinusBtn').style.display = 'flex'; document.getElementById('fontSizeDisplay').style.display = 'inline-block'; document.getElementById('fontSizeDisplay').textContent = textFontSize + 'px';
    document.getElementById('fontPlusBtn').style.display = 'flex';
  { const _b=document.getElementById('bgColorBtn'); const _d=document.getElementById('bgColorDot'); if(_b)_b.style.display='flex'; if(_d)_d.style.background=TEXT_BG_COLORS[textBgColorIdx].dot; }
    document.getElementById('editTextBtn').style.opacity = '1';
    document.getElementById('editTextBtn').style.cursor = 'pointer';
    
  }
  showToast('Arraste o texto para reposicionar', '');
}

function editSavedTextById(annId, e) {
  if (e) e.stopPropagation();
  const anns = annotations[currentMediaId] || [];
  const idx = anns.findIndex(a => a._id === annId);
  if (idx < 0) return;
  editSavedText(idx, e);
}

function editSavedText(index, e) {
  if (e) e.stopPropagation();
  const ann = (annotations[currentMediaId] || [])[index];
  if (!ann || ann.kind !== 'text') return;
  
  if (!isImageMode) {
    const editTime = safeAnnotationTime(video.currentTime);
    // ann.text sempre tem o valor mais recente ap√≥s cada edi√ß√£o
    const currentText = ann.text || '';
    video.pause();
    const input = document.getElementById('textPopupInput');
    input.value = currentText;
    document.getElementById('textPopup').classList.add('active');
    setTimeout(() => input.focus(), 100);
    window._editingAnnIndex = index;
    window._editingEditTime = editTime;
    window._lastEditingAnnId = ann._id;
    return;
  }
  
  // Image mode: original behavior (remove and re-open)
  annotations[currentMediaId].splice(index, 1);
  dismissedTimes.delete(ann.time);
  renderSavedArrows();
  renderAnnotationsList();
  updateBadge(currentMediaId);
  // Restore state
  pendingTime = ann.time;
  pendingTextContent = ann.text || '';
  textXPct = ann.xPct; textYPct = ann.yPct;
  textRotation = ann.rotation || 0;
  textFontSize = ann.fontSize || 15;
  textEl.childNodes[0].textContent = pendingTextContent;
  textEl.style.fontSize = textFontSize + 'px';
  textEl.style.width = ann.customWidth || '';
  textEl.style.height = ann.customHeight || '';
  textEl.style.display = 'block';
  textEl.style.background = TEXT_BG_COLORS[textBgColorIdx].value;
  placeText(textXPct, textYPct);
  textMode = true;
  activeMode = 'text';
  textBtn.classList.add('active');
  doneBtn.style.display = 'flex';
  document.getElementById('fontMinusBtn').style.display = 'flex'; document.getElementById('fontSizeDisplay').style.display = 'inline-block'; document.getElementById('fontSizeDisplay').textContent = textFontSize + 'px';
  document.getElementById('fontPlusBtn').style.display = 'flex';
  { const _b=document.getElementById('bgColorBtn'); const _d=document.getElementById('bgColorDot'); if(_b)_b.style.display='flex'; if(_d)_d.style.background=TEXT_BG_COLORS[textBgColorIdx].dot; }
  document.getElementById('editTextBtn').style.opacity = '1'; document.getElementById('editTextBtn').style.cursor = 'pointer';
  
  // Open edit popup immediately
  document.getElementById('textPopupInput').value = pendingTextContent;
  document.getElementById('textPopup').classList.add('active');
  setTimeout(() => document.getElementById('textPopupInput').focus(), 100);
}

function moveArrowAtTime(index) {
  const ann = (annotations[currentMediaId] || [])[index];
  if (!ann || (ann.kind && ann.kind !== 'arrow')) return;
  if (arrowMode || textMode) { showToast('Conclua ou desfa√ßa a anota√ß√£o antes de continuar.', 'error'); return; }
  video.pause();
  const moveTime = safeAnnotationTime(video.currentTime);
  // Get current displayed position for this time
  let startX = ann.xPct, startY = ann.yPct, startRot = ann.rotation || 0;
  if (ann.moves && ann.moves.length > 0) {
    const t = video.currentTime;
    for (const move of ann.moves) {
      if (move.time <= t + 0.05) { startX = move.xPct; startY = move.yPct; startRot = move.rotation || 0; }
    }
  }
  // Store which annotation we're moving, and its original moves array
  window._movingArrowIndex = index;
  window._movingArrowTime = moveTime;
  window._movingArrowOrigMoves = ann.moves ? JSON.parse(JSON.stringify(ann.moves)) : [{ time: ann.time, xPct: ann.xPct, yPct: ann.yPct, rotation: ann.rotation || 0 }];
  // Remove from array temporarily, enter arrowMode with current position
  annotations[currentMediaId].splice(index, 1);
  renderSavedArrows(); renderAnnotationsList(); updateBadge(currentMediaId);
  arrowMode = true;
  activeMode = 'arrow';
  pendingTime = ann.time; // keep original time
  arrowXPct = startX; arrowYPct = startY; arrowRotation = startRot;
  placeArrow(arrowXPct, arrowYPct);
  arrowEl.style.display = 'block';
  arrowHint.style.display = 'none';
  arrowBtn.classList.add('active');
  doneBtn.style.display = 'flex';
  showToast('‚§¢ Reposicione a seta e clique Conclu√≠do', '');
}

function toggleAnnotationsList() {
  const panel = document.getElementById('annotationsPanel');
  panel.classList.toggle('visible');
  renderAnnotationsList();
}

// ‚îÄ‚îÄ‚îÄ FORCE PLAY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function forcePlay() {
  if (arrowMode || textMode) {
    showToast('Conclua ou desfa√ßa a anota√ß√£o antes de continuar.', 'error');
    return;
  }
  if (screenRecordMode) return; // screen record handles its own resume
  const anns = annotations[currentMediaId] || [];
  let closest = null;
  let minDist = Infinity;
  for (const ann of anns) {
    const dist = Math.abs(video.currentTime - ann.time);
    if (dist < minDist) { minDist = dist; closest = ann; }
  }
  if (closest && minDist < 2) dismissedTimes.add(closest.time);
  video.play();
}

// ‚îÄ‚îÄ‚îÄ BACKUP & RESTORE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function downloadBackup() {
  if (mediaItems.length === 0) {
    showToast('Nenhum item na galeria para fazer backup.', 'error');
    return;
  }

  showToast('‚è≥ Gerando backup ZIP...', '', 120000);

  try {
    const zip = new JSZip();
    const meta = { version: 3, exportedAt: new Date().toISOString(), media: [] };

    for (const item of mediaItems) {
      // Fetch the blob URL as binary
      const response = await fetch(item.url);
      const blob = await response.blob();
      const arrayBuffer = await blob.arrayBuffer();

      // Store binary directly in zip (no base64 overhead)
      const ext = item.name.split('.').pop();
      const safeFilename = item.name.replace(/[^a-zA-Z0-9._-]/g, '_');
      zip.file(`media/${safeFilename}`, arrayBuffer);

      meta.media.push({
        name: item.name,
        safeFilename,
        type: item.type,
        mimeType: blob.type,
        annotations: (annotations[item.id] || []).map(ann => ({
          kind: ann.kind || 'arrow',
          time: ann.time,
          timeFormatted: formatTime(ann.time),
          xPct: ann.xPct,
          yPct: ann.yPct,
          rotation: ann.rotation || 0,
          moves: ann.moves || undefined,
          trimEndAt: ann.trimEndAt != null ? ann.trimEndAt : undefined,
          ...(ann.text ? { text: ann.text } : {}),
          ...(ann.fontSize ? { fontSize: ann.fontSize } : {}),
          ...(ann.bgColor ? { bgColor: ann.bgColor } : {}),
          ...(ann.customWidth ? { customWidth: ann.customWidth } : {}),
          ...(ann.customHeight ? { customHeight: ann.customHeight } : {}),
          ...(ann.dataUrl ? { dataUrl: ann.dataUrl } : {}),
          _id: ann._id
        })),
        textPlaylist: (textPlaylists[item.id] || []).map(pl => ({
          kind: pl.kind || 'text',
          text: pl.text || '',
          fontSize: pl.fontSize || 15,
          bgColor: pl.bgColor || 'rgba(232,255,71,0.92)',
          backText: pl.backText || '',
          customWidth: pl.customWidth || null,
          customHeight: pl.customHeight || null,
          time: pl.time,
          savedTrimStart: pl.savedTrimStart != null ? pl.savedTrimStart : 0,
          savedTrimEnd: pl.savedTrimEnd != null ? pl.savedTrimEnd : null,
          dataUrl: pl.dataUrl || null,
          subCards: (pl.subCards || []).map(sc => ({
            front: sc.front || '',
            back: sc.back || '‚Äî',
            ...(sc.frontImg ? { frontImg: sc.frontImg } : {}),
            ...(sc.backImg ? { backImg: sc.backImg } : {})
          }))
        }))
      });
    }

    zip.file('backup.json', JSON.stringify(meta, null, 2));

    const zipBlob = await zip.generateAsync({ type: 'blob', compression: 'STORE' });
    const url = URL.createObjectURL(zipBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `frame-backup-${new Date().toISOString().slice(0,10)}.zip`;
    a.click();
    URL.revokeObjectURL(url);

    const sizeMB = (zipBlob.size / 1024 / 1024).toFixed(1);
    showToast(`‚úì Backup ZIP gerado! (${sizeMB} MB)`, 'success');
  } catch (err) {
    showToast('Erro ao gerar backup: ' + err.message, 'error');
  }
}

async function restoreBackup(e) {
  const file = e.target.files[0];
  if (!file) return;

  showToast('‚è≥ Carregando backup...', '', 120000);

  try {
    const zip = await JSZip.loadAsync(file);

    // Read metadata
    const metaFile = zip.file('backup.json');
    if (!metaFile) throw new Error('backup.json n√£o encontrado no ZIP');
    const meta = JSON.parse(await metaFile.async('text'));

    if (!meta.version || !meta.media) throw new Error('Formato inv√°lido');

    // Clear gallery
    mediaItems = [];
    annotations = {};
    textPlaylists = {};
    pendingAnnotations = [];
    const grid = document.getElementById('galleryGrid');
    grid.innerHTML = `<div class="empty-state">
      <div class="icon">üé¨</div>
      <h3>Galeria vazia</h3>
      <p>Importe fotos e v√≠deos para come√ßar</p>
    </div>`;

    for (const entry of meta.media) {
      const safeFilename = entry.safeFilename || entry.name.replace(/[^a-zA-Z0-9._-]/g, '_');
      const zipEntry = zip.file(`media/${safeFilename}`);
      if (!zipEntry) {
        showToast(`Arquivo n√£o encontrado no ZIP: ${entry.name}`, 'error', 5000);
        continue;
      }

      const arrayBuffer = await zipEntry.async('arraybuffer');
      const blob = new Blob([arrayBuffer], { type: entry.mimeType });
      const url = URL.createObjectURL(blob);

      const id = Date.now() + '_' + Math.random().toString(36).substr(2,8);
      const item = { id, name: entry.name, type: entry.type, url };
      mediaItems.push(item);
      annotations[id] = (entry.annotations || []).map(ann => ({
        kind: ann.kind || 'arrow',
        time: ann.time,
        xPct: ann.xPct,
        yPct: ann.yPct,
        rotation: ann.rotation || 0,
        moves: ann.moves || undefined,
        trimEndAt: ann.trimEndAt != null ? ann.trimEndAt : undefined,
        ...(ann.text ? { text: ann.text } : {}),
        ...(ann.fontSize ? { fontSize: ann.fontSize } : {}),
        ...(ann.bgColor ? { bgColor: ann.bgColor } : {}),
        ...(ann.customWidth ? { customWidth: ann.customWidth } : {}),
        ...(ann.customHeight ? { customHeight: ann.customHeight } : {}),
        ...(ann.dataUrl ? { dataUrl: ann.dataUrl } : {}),
        _id: ann._id || (_annIdCounter++ + '_r')
      }));
      textPlaylists[id] = (entry.textPlaylist || []).map(pl => ({
        kind: pl.kind || 'text',
        text: pl.text || '',
        fontSize: pl.fontSize || 15,
        bgColor: pl.bgColor || 'rgba(232,255,71,0.92)',
        backText: pl.backText || '',
        customWidth: pl.customWidth || null,
        customHeight: pl.customHeight || null,
        time: pl.time,
        savedTrimStart: pl.savedTrimStart != null ? pl.savedTrimStart : 0,
        savedTrimEnd: pl.savedTrimEnd != null ? pl.savedTrimEnd : null,
        dataUrl: pl.dataUrl || null,
        subCards: (pl.subCards || []).map(sc => ({
          front: sc.front || '',
          back: sc.back || '‚Äî',
          ...(sc.frontImg ? { frontImg: sc.frontImg } : {}),
          ...(sc.backImg ? { backImg: sc.backImg } : {}),
          _flipped: false
        })),
        _flipped: false
      }));
      addGalleryCard(item);
      updateBadge(id);
    }

    showToast(`‚úì ${meta.media.length} arquivo(s) restaurados!`, 'success');
  } catch (err) {
    showToast('Erro ao restaurar: ' + err.message, 'error');
  }

  document.getElementById('jsonInput').value = '';
}

// ‚îÄ‚îÄ‚îÄ SCREEN RECORD MODE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let screenRecordMode = false;
let screenRecordPauseTimeout = null;
let trimStart = 0; // artificial trim start point
let trimEnd = Infinity; // artificial trim end point
let trimLoop = false; // loop autom√°tico entre trimStart e trimEnd
let rewindOnNextPlay = false; // flag: rewind to trimStart when user hits play
let rewindToTime = null;      // tempo espec√≠fico para rebobinar (texto/playlist), null = usar trimStart

function toggleScreenRecord() {
  if (screenRecordMode) {
    stopScreenRecord();
  } else {
    startScreenRecord();
  }
}

// ‚îÄ‚îÄ‚îÄ CHECKMARK ANNOTATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let checkmarkPending = false; // waiting for end mark
let checkmarkStart = null;    // time when ‚úÖ should appear

function toggleCheckmark() {
  const btn = document.getElementById('checkBtn');
  const content = document.getElementById('checkBtnContent');
  if (!checkmarkPending) {
    checkmarkStart = safeAnnotationTime(video.currentTime);
    checkmarkPending = true;
    btn.style.color = 'var(--accent)';
    btn.style.borderColor = 'var(--accent)';
    btn.style.background = 'rgba(232,255,71,0.15)';
    if (content) content.innerHTML = `‚úÖ<br><span style="font-size:9px;font-family:'Syne',sans-serif;">${formatShortTime(checkmarkStart)}</span><br><span style="font-size:11px;">‚úï</span>`;
    showToast('‚úÖ In√≠cio marcado ‚Äî clique de novo para definir o fim', 'success');
    updateCheckmarkOverlay(video.currentTime);
    updateAnnotationMarkers(); updateStoryButtons();
  } else {
    const checkmarkEnd = safeAnnotationTime(video.currentTime);
    if (checkmarkEnd <= checkmarkStart) {
      showToast('O fim deve ser depois do in√≠cio!', 'error');
      return;
    }
    checkmarkPending = false;
    btn.style.color = '';
    btn.style.borderColor = '';
    btn.style.background = '';
    if (content) content.innerHTML = `‚úÖ<br><span style="font-size:9px;font-family:'Syne',sans-serif;">${formatShortTime(checkmarkStart)} ‚Üí ${formatShortTime(checkmarkEnd)}</span>`;
    setTimeout(() => { if (content) content.textContent = '‚úÖ'; }, 2000);
    if (!annotations[currentMediaId]) annotations[currentMediaId] = [];
    annotations[currentMediaId].push({
      kind: 'checkmark',
      timeStart: checkmarkStart,
      timeEnd: checkmarkEnd,
      time: checkmarkStart,
      _id: _newAnnId()
    });
    emojiRedoStack = [];
    lastSavedAnnId = annotations[currentMediaId][annotations[currentMediaId].length - 1]._id;
    updateBadge(currentMediaId);
    showToast(`‚úÖ Marcado de ${formatTime(checkmarkStart)} at√© ${formatTime(checkmarkEnd)}`, 'success');
    checkmarkStart = null;
    updateAnnotationMarkers(); updateStoryButtons();
    renderSkipZones();
    const savedAnn = annotations[currentMediaId][annotations[currentMediaId].length - 1];
    previewAnnotation(savedAnn);
  }
}

function previewAnnotation(ann) {
  // Clear dismissed keys for this annotation so pauses fire when playing through
  dismissedTimes.delete(`${ann.kind}_start_${ann.timeStart}`);
  dismissedTimes.delete(`${ann.kind}_end_${ann.timeEnd}`);
  // Seek to timeStart and pause, then force overlay after seek completes
  video.pause();
  internalSeek = true;
  video.currentTime = ann.timeStart;
}

// ‚îÄ‚îÄ‚îÄ STORY NAVIGATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getAnnotationPoints() {
  const anns = (annotations[currentMediaId] || []).filter(a => a.kind === 'checkmark' || a.kind === 'xmark');
  const points = [];
  for (const a of anns) {
    points.push({ time: a.timeStart, ann: a });
    points.push({ time: a.timeEnd, ann: a });
  }
  points.sort((a, b) => a.time - b.time);
  return points;
}

function jumpToPoint(dir) {
  const points = getAnnotationPoints();
  if (!points.length) return;
  const t = video.currentTime;
  let idx;
  if (dir === 1) {
    idx = points.findIndex(p => p.time > t + 0.1);
    if (idx === -1) idx = points.length - 1;
  } else {
    // Last point strictly before current time (with tolerance)
    let found = -1;
    for (let i = points.length - 1; i >= 0; i--) {
      if (points[i].time < t - 0.1) { found = i; break; }
    }
    idx = found === -1 ? 0 : found;
  }
  internalSeek = true;
  video.currentTime = points[idx].time;
  for (const key of [...dismissedTimes]) {
    const m = typeof key === 'string' && key.match(/_(\d+\.?\d*)$/);
    const num = m ? parseFloat(m[1]) : parseFloat(key);
    if (!isNaN(num) && Math.abs(num - points[idx].time) < 0.5) dismissedTimes.delete(key);
  }
}

function storyNavigate(dir) {
  const points = getAnnotationPoints();
  if (!points.length) return;
  const t = video.currentTime;
  let idx;
  if (dir === 1) {
    // Next: first point strictly after current time
    idx = points.findIndex(p => p.time > t + 0.1);
    if (idx === -1) idx = points.length - 1;
  } else {
    // Back 2: go back 2 points from current position
    const curIdx = points.findIndex(p => p.time >= t - 0.1);
    idx = curIdx === -1 ? points.length - 3 : curIdx - 2;
    idx = Math.max(0, idx);
  }
  video.pause();
  internalSeek = true;
  video.currentTime = points[idx].time;
  // Re-arm dismissed times around new position
  for (const key of [...dismissedTimes]) {
    const m = typeof key === 'string' && key.match(/_(\d+\.?\d*)$/);
    const num = m ? parseFloat(m[1]) : parseFloat(key);
    if (!isNaN(num) && Math.abs(num - points[idx].time) < 0.5) dismissedTimes.delete(key);
  }
}

function updateStoryButtons() {
  const show = !!(currentMediaId && (annotations[currentMediaId] || []).some(a => a.kind === 'checkmark' || a.kind === 'xmark'));
  const prev = document.getElementById('storyPrev');
  const next = document.getElementById('storyNext');
  if (prev) prev.style.display = show ? 'flex' : 'none';
  if (next) next.style.display = show ? 'flex' : 'none';
}

function animatePopIn(el) {
  const duration = 400;
  const start = performance.now();
  el.style.transform = 'scale(0.05)';
  function frame(now) {
    const t = Math.min(1, (now - start) / duration);
    const s = t < 0.6 ? (t / 0.6) * 1.1 : 1.1 - ((t - 0.6) / 0.4) * 0.1;
    el.style.transform = `scale(${s})`;
    if (t < 1) requestAnimationFrame(frame);
    else el.style.transform = 'scale(1)';
  }
  requestAnimationFrame(frame);
}

function updateCheckmarkOverlay(t) {
  const overlay = document.getElementById('checkmarkOverlay');
  if (!overlay) return;
  const anns = annotations[currentMediaId] || [];
  let active = false;
  let activeAnn = null;

  for (const a of anns) {
    if (a.kind !== 'checkmark') continue;
    if (t >= a.timeStart && t <= a.timeEnd) { active = true; activeAnn = a; break; }
  }
  if (!active && checkmarkPending && checkmarkStart !== null && t >= checkmarkStart) active = true;

  const wasHidden = overlay.style.display === 'none';
  overlay.style.display = active ? 'flex' : 'none';
  const inner = document.getElementById('checkmarkEmoji');
  if (inner) {
    inner.style.opacity = '0.25';
    if (active && wasHidden) {
      if (video.paused) {
        // Show immediately without animation when paused
        inner.style.transform = 'scale(1)';
      } else {
        inner.style.transform = 'scale(0.05)';
        requestAnimationFrame(() => animatePopIn(inner));
      }
    }
  }
  // Update progress bar
  const fill = document.getElementById('checkmarkProgressFill');
  if (fill && activeAnn) {
    const pct = ((t - activeAnn.timeStart) / (activeAnn.timeEnd - activeAnn.timeStart)) * 100;
    fill.style.width = Math.max(0, Math.min(100, pct)) + '%';
  } else if (fill) {
    fill.style.width = '0%';
  }
}

// ‚îÄ‚îÄ‚îÄ XMARK ANNOTATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let xmarkPending = false;
let xmarkStart = null;

function toggleXmark() {
  const btn = document.getElementById('xmarkBtn');
  const content = document.getElementById('xmarkBtnContent');
  if (!xmarkPending) {
    xmarkStart = safeAnnotationTime(video.currentTime);
    xmarkPending = true;
    btn.style.color = '#f87171';
    btn.style.borderColor = '#f87171';
    btn.style.background = 'rgba(248,113,113,0.15)';
    if (content) content.innerHTML = `‚ùå<br><span style="font-size:9px;font-family:'Syne',sans-serif;">${formatShortTime(xmarkStart)}</span><br><span style="font-size:11px;">‚úï</span>`;
    showToast('‚ùå In√≠cio marcado ‚Äî clique de novo para definir o fim', 'error');
    updateXmarkOverlay(video.currentTime);
    updateAnnotationMarkers(); updateStoryButtons();
  } else {
    const xmarkEnd = safeAnnotationTime(video.currentTime);
    if (xmarkEnd <= xmarkStart) {
      showToast('O fim deve ser depois do in√≠cio!', 'error');
      return;
    }
    xmarkPending = false;
    btn.style.color = '';
    btn.style.borderColor = '';
    btn.style.background = '';
    if (content) content.innerHTML = `‚ùå<br><span style="font-size:9px;font-family:'Syne',sans-serif;">${formatShortTime(xmarkStart)} ‚Üí ${formatShortTime(xmarkEnd)}</span>`;
    setTimeout(() => { if (content) content.textContent = '‚ùå'; }, 2000);
    if (!annotations[currentMediaId]) annotations[currentMediaId] = [];
    annotations[currentMediaId].push({
      kind: 'xmark',
      timeStart: xmarkStart,
      timeEnd: xmarkEnd,
      time: xmarkStart,
      _id: _newAnnId()
    });
    emojiRedoStack = [];
    lastSavedAnnId = annotations[currentMediaId][annotations[currentMediaId].length - 1]._id;
    updateBadge(currentMediaId);
    showToast(`‚ùå Marcado de ${formatTime(xmarkStart)} at√© ${formatTime(xmarkEnd)}`, '');
    const savedAnn = annotations[currentMediaId][annotations[currentMediaId].length - 1];
    xmarkStart = null;
    updateAnnotationMarkers(); updateStoryButtons();
    renderSkipZones();
    previewAnnotation(savedAnn);
  }
}

function showStaticOverlay(kind) {
  document.getElementById('staticCheckOverlay').style.display = kind === 'checkmark' ? 'flex' : 'none';
  document.getElementById('staticXOverlay').style.display = kind === 'xmark' ? 'flex' : 'none';
}
function hideStaticOverlays() {
  document.getElementById('staticCheckOverlay').style.display = 'none';
  document.getElementById('staticXOverlay').style.display = 'none';
}

function updateXmarkOverlay(t) {
  const overlay = document.getElementById('xmarkOverlay');
  if (!overlay) return;
  const anns = annotations[currentMediaId] || [];
  let active = false;
  let activeAnn = null;

  for (const a of anns) {
    if (a.kind !== 'xmark') continue;
    if (t >= a.timeStart && t <= a.timeEnd) { active = true; activeAnn = a; break; }
  }
  if (!active && xmarkPending && xmarkStart !== null && t >= xmarkStart) active = true;

  const wasHidden = overlay.style.display === 'none';
  overlay.style.display = active ? 'flex' : 'none';
  const inner = document.getElementById('xmarkEmoji');
  if (inner) {
    inner.style.opacity = '0.25';
    if (active && wasHidden) {
      if (video.paused) {
        // Show immediately without animation when paused
        inner.style.transform = 'scale(1)';
      } else {
        inner.style.transform = 'scale(0.05)';
        requestAnimationFrame(() => animatePopIn(inner));
      }
    }
  }
  // Update progress bar
  const fill = document.getElementById('xmarkProgressFill');
  if (fill && activeAnn) {
    const pct = ((t - activeAnn.timeStart) / (activeAnn.timeEnd - activeAnn.timeStart)) * 100;
    fill.style.width = Math.max(0, Math.min(100, pct)) + '%';
  } else if (fill) {
    fill.style.width = '0%';
  }
}

function toggleMute() {
  const btn = document.getElementById('muteBtn');
  video.muted = !video.muted;
  btn.textContent = video.muted ? 'üîá' : 'üîä';
  btn.style.color = video.muted ? 'var(--accent)' : '';
  btn.style.borderColor = video.muted ? 'var(--accent)' : '';
}

function toggleSpeed() {
  const btn = document.getElementById('speedBtn');
  if (video.playbackRate === 1) {
    video.playbackRate = 0.5;
    btn.style.color = 'var(--accent)';
    btn.style.borderColor = 'var(--accent)';
    showToast('Velocidade: 0.5x', 'success');
  } else {
    video.playbackRate = 1;
    btn.style.color = '';
    btn.style.borderColor = '';
    showToast('Velocidade: normal', '');
  }
}

function setTrimStart() {
  const btn = document.getElementById('trimBtn');
  if (trimStart > 0) {
    trimStart = 0;
    updateTrimVisuals();
    if (btn) { btn.style.color = ''; btn.style.borderColor = ''; }
    showToast('[ Marca√ß√£o de in√≠cio removida', '');
  } else {
    trimStart = video.currentTime;
    updateTrimVisuals();
    if (btn) { btn.style.color = 'var(--accent)'; btn.style.borderColor = 'var(--accent)'; }
    showToast(`‚ñ∂ In√≠cio definido em ${formatTime(trimStart)}`, 'success');
  }
}

function updateTrimMarker() { updateTrimVisuals(); }
function updateTrimEndMarker() { updateTrimVisuals(); }

function setTrimEnd() {
  const btn = document.getElementById('trimEndBtn');
  if (isFinite(trimEnd)) {
    trimEnd = Infinity;
    updateTrimVisuals();
    if (btn) { btn.style.color = ''; btn.style.borderColor = ''; }
    showToast('] Marca√ß√£o de fim removida', '');
  } else {
    trimEnd = video.currentTime;
    updateTrimVisuals();
    if (btn) { btn.style.color = 'var(--accent)'; btn.style.borderColor = 'var(--accent)'; }
    showToast(`‚ñ† Fim definido em ${formatTime(trimEnd)}`, 'success');
  }
}

function toggleTrimLoop() {
  trimLoop = !trimLoop;
  const btn = document.getElementById('loopBtn');
  if (btn) {
    btn.style.color = trimLoop ? '#e8ff47' : '';
    btn.style.borderColor = trimLoop ? '#e8ff47' : '';
    btn.style.background = trimLoop ? 'rgba(232,255,71,0.15)' : '';
  }
  if (trimLoop) {
    // Ir para o trimStart e dar play
    video.pause();
    internalSeek = true;
    dismissedTimes.clear();
    pauseQueueIdx = 0;
    video.currentTime = trimStart > 0 ? trimStart : 0;
    video.addEventListener('seeked', function onLoopStart() {
      video.removeEventListener('seeked', onLoopStart);
      video.play();
    }, { once: true });
    showToast('üîÅ Loop ativado', 'success');
  } else {
    showToast('üîÅ Loop desativado', '');
  }
}

function rewindToTrimStart() {
  if (!video.duration) return;
  internalSeek = true;
  video.currentTime = trimStart;
  video.pause();
  renderSavedArrows(trimStart);
  showToast(`‚èÆÔ∏è ${formatShortTime(trimStart)}`, '');
}

function trimABackToCurrent() {
  if (!video.duration) return;
  const t = video.currentTime;
  const MIN_GAP = 0.5;
  trimStart = Math.max(0, Math.min(t, (isFinite(trimEnd) ? trimEnd : video.duration) - MIN_GAP));
  internalSeek = true;
  video.currentTime = trimStart;
  updateTrimVisuals();
  buildPauseQueue();
  advancePauseQueueTo(video.currentTime);
  renderSavedArrows(video.currentTime);
  showToast(`‚ñ∂ Trim A ‚Üí ${formatShortTime(trimStart)}`, '');
}

function trimBBackToCurrent() {
  if (!video.duration) return;
  const t = video.currentTime;
  const MIN_GAP = 0.5;
  trimEnd = Math.min(video.duration, Math.max(t, trimStart + MIN_GAP));
  internalSeek = true;
  video.currentTime = trimEnd;
  updateTrimVisuals();
  buildPauseQueue();
  advancePauseQueueTo(video.currentTime);
  renderSavedArrows(video.currentTime);
  showToast(`‚ñ† Trim B ‚Üí ${formatShortTime(trimEnd)}`, '');
}

function updateAnnotationMarkers() {
  // Remove all existing emoji markers
  document.querySelectorAll('.ann-emoji-marker').forEach(el => el.remove());
  if (!video.duration || !currentMediaId) return;
  const track = document.getElementById('progressTrack');
  const anns = annotations[currentMediaId] || [];
  anns.forEach(ann => {
    if (ann.kind !== 'checkmark' && ann.kind !== 'xmark') return;
    const emoji = ann.kind === 'checkmark' ? '‚úÖ' : '‚ùå';
    // Start marker
    const pctStart = (ann.timeStart / video.duration) * 100;
    const mStart = document.createElement('div');
    mStart.className = 'ann-emoji-marker';
    mStart.style.cssText = `position:absolute;left:${pctStart}%;top:-22px;transform:translateX(-50%);font-size:14px;pointer-events:none;z-index:6;line-height:1;`;
    mStart.textContent = emoji;
    track.appendChild(mStart);
    // End marker
    const pctEnd = (ann.timeEnd / video.duration) * 100;
    const mEnd = document.createElement('div');
    mEnd.className = 'ann-emoji-marker';
    mEnd.style.cssText = `position:absolute;left:${pctEnd}%;top:-22px;transform:translateX(-50%);font-size:14px;pointer-events:none;z-index:6;line-height:1;`;
    mEnd.textContent = emoji;
    track.appendChild(mEnd);
  });
  // Also show pending start marker
  if (checkmarkPending && checkmarkStart !== null) {
    const pct = (checkmarkStart / video.duration) * 100;
    const m = document.createElement('div');
    m.className = 'ann-emoji-marker';
    m.style.cssText = `position:absolute;left:${pct}%;top:-22px;transform:translateX(-50%);font-size:14px;pointer-events:none;z-index:6;line-height:1;opacity:0.5;`;
    m.textContent = '‚úÖ';
    track.appendChild(m);
  }
  if (xmarkPending && xmarkStart !== null) {
    const pct = (xmarkStart / video.duration) * 100;
    const m = document.createElement('div');
    m.className = 'ann-emoji-marker';
    m.style.cssText = `position:absolute;left:${pct}%;top:-22px;transform:translateX(-50%);font-size:14px;pointer-events:none;z-index:6;line-height:1;opacity:0.5;`;
    m.textContent = '‚ùå';
    track.appendChild(m);
  }
}

function startScreenRecord() {
  if (!currentMediaId) return;
  const anns = annotations[currentMediaId] || [];

  screenRecordMode = true;

  // Visual feedback on button
  const btn = document.getElementById('recordBtn');
  btn.style.background = '#f87171';
  btn.style.color = '#000';
  btn.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><rect x="6" y="6" width="12" height="12" rx="2"/></svg> Parar`;

  // Hide toolbar and close button for clean view
  document.getElementById('videoToolbar').style.opacity = '0';
  document.getElementById('videoToolbar').style.pointerEvents = 'none';
  document.querySelector('.modal-close').style.opacity = '0';
  document.querySelector('.modal-close').style.pointerEvents = 'none';
  document.getElementById('videoContainer').classList.add('recording-mode');
  document.getElementById('recordExitBtn').style.display = 'block';

  // Reset dismissedTimes so all annotations fire (but only those after trimStart)
  dismissedTimes = new Set();
  for (const ann of annotations[currentMediaId] || []) {
    if (ann.time < trimStart || ann.time > trimEnd) dismissedTimes.add(ann.time);
  }

  // Rewind to trimStart and play
  internalSeek = true;
  video.currentTime = trimStart;
  video.addEventListener('seeked', function onStart() {
    video.removeEventListener('seeked', onStart);
    video.play();
  }, { once: true });
}

// ‚îÄ‚îÄ‚îÄ SKIP BLOCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let skipPairs = [];       // [{a: seconds, b: seconds}, ...]
let skipPending = null;   // time of current pending start (odd click), or null
let skipFiring = false;

function renderSkipZones() {
  const container = document.getElementById('skipZonesContainer');
  if (!container) return;
  container.innerHTML = '';
  const dur = video.duration;
  if (!dur || isNaN(dur)) return;

  const anns = annotations[currentMediaId] || [];

  // ‚úÖ checkmark zones - green
  for (const a of anns) {
    if (a.kind !== 'checkmark') continue;
    const leftPct = (a.timeStart / dur) * 100;
    const widthPct = ((a.timeEnd - a.timeStart) / dur) * 100;
    const zone = document.createElement('div');
    zone.style.cssText = `position:absolute;top:0;bottom:0;left:${leftPct}%;width:${widthPct}%;background:rgba(74,222,128,0.55);pointer-events:none;`;
    container.appendChild(zone);
  }

  // ‚ùå xmark zones - red
  for (const a of anns) {
    if (a.kind !== 'xmark') continue;
    const leftPct = (a.timeStart / dur) * 100;
    const widthPct = ((a.timeEnd - a.timeStart) / dur) * 100;
    const zone = document.createElement('div');
    zone.style.cssText = `position:absolute;top:0;bottom:0;left:${leftPct}%;width:${widthPct}%;background:rgba(248,113,113,0.55);pointer-events:none;`;
    container.appendChild(zone);
  }

  // ‚¨õ skip zones - gray
  for (const pair of skipPairs) {
    const leftPct = (pair.a / dur) * 100;
    const widthPct = ((pair.b - pair.a) / dur) * 100;
    const zone = document.createElement('div');
    zone.style.cssText = `position:absolute;top:0;bottom:0;left:${leftPct}%;width:${widthPct}%;background:rgba(160,160,160,0.55);pointer-events:none;`;
    container.appendChild(zone);
  }

  // Pending skip A marker - yellow line
  if (skipPending !== null) {
    const leftPct = (skipPending / dur) * 100;
    const zone = document.createElement('div');
    zone.style.cssText = `position:absolute;top:0;bottom:0;left:${leftPct}%;width:2px;background:var(--accent);pointer-events:none;`;
    container.appendChild(zone);
  }
}

function toggleSkipBlock() {
  const btn = document.getElementById('skipBlockBtn');
  const resetBtn = document.getElementById('skipResetBtn');

  if (skipPending === null) {
    // Odd click: define in√≠cio de novo segmento
    skipPending = video.currentTime;
    btn.style.color = 'var(--accent)';
    btn.style.borderColor = 'var(--accent)';
    btn.style.background = 'rgba(232,255,71,0.12)';
    const label = String.fromCharCode(65 + skipPairs.length * 2); // A, C, E...
    btn.innerHTML = `‚¨õ <span style="font-size:9px;font-family:'Syne',sans-serif;">${label}:${formatShortTime(skipPending)}</span>`;
    showToast(`‚¨õ Ponto ${label} marcado ‚Äî clique de novo para fechar o bloco`, 'success');
    renderSkipZones();
  } else {
    // Even click: fecha o segmento atual
    if (video.currentTime <= skipPending) {
      showToast('O ponto de fim deve ser depois do in√≠cio!', 'error');
      return;
    }
    skipPairs.push({ a: skipPending, b: video.currentTime, _id: ++_annCounter });
    skipPending = null;
    emojiRedoStack = [];

    updateSkipBtn();
    const n = skipPairs.length;
    const last = skipPairs[n - 1];
    const labelA = String.fromCharCode(65 + (n - 1) * 2);
    const labelB = String.fromCharCode(66 + (n - 1) * 2);
    showToast(`‚¨õ Bloco ${n}: ${labelA}(${formatShortTime(last.a)}) ‚Üí ${labelB}(${formatShortTime(last.b)}) ‚Äî clique para adicionar mais`, 'success');
    if (resetBtn) resetBtn.style.display = 'inline-flex';
    renderSkipZones();
  }
}

function resetSkipBlock() {
  skipPairs = [];
  skipPending = null;
  skipFiring = false;
  const btn = document.getElementById('skipBlockBtn');
  const resetBtn = document.getElementById('skipResetBtn');
  btn.style.color = '';
  btn.style.borderColor = '';
  btn.style.background = '';
  btn.innerHTML = '‚¨õ';
  if (resetBtn) resetBtn.style.display = 'none';
  showToast('‚¨õ Todos os blocos de skip removidos', '');
  renderSkipZones();
}

function updateSkipBtn() {
  const btn = document.getElementById('skipBlockBtn');
  const n = skipPairs.length;
  if (n === 0) { btn.innerHTML = '‚¨õ'; btn.style.color = ''; btn.style.borderColor = ''; btn.style.background = ''; return; }
  btn.style.color = '#fff';
  btn.style.borderColor = '#555';
  btn.style.background = '#111';
  const pairs = skipPairs.map((p, i) => {
    const la = String.fromCharCode(65 + i * 2);
    const lb = String.fromCharCode(66 + i * 2);
    return `${la}‚Üí${lb}`;
  }).join(' ');
  btn.innerHTML = `‚¨õ <span style="font-size:9px;font-family:'Syne',sans-serif;">${pairs}</span>`;
}

function checkAndSkipBlock() {
  if (skipPairs.length === 0 || skipFiring) return;
  const t = video.currentTime;
  for (const pair of skipPairs) {
    if (t >= pair.a && t <= pair.a + 0.2) {
      skipFiring = true;
      const black = document.getElementById('skipVideoBlack');
      if (black) black.style.display = 'block';
      video.pause();
      internalSeek = true;
      video.currentTime = pair.b;
      video.addEventListener('seeked', function onSkipSeeked() {
        video.removeEventListener('seeked', onSkipSeeked);
        setTimeout(() => {
          if (black) black.style.display = 'none';
          skipFiring = false;
          // pausa no ponto B
        }, 300);
      }, { once: true });
      break;
    }
  }
}

function stopScreenRecord() {
  screenRecordMode = false;
  clearTimeout(screenRecordPauseTimeout);

  const btn = document.getElementById('recordBtn');
  btn.style.background = '';
  btn.style.color = '#f87171';
  btn.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><circle cx="12" cy="12" r="8"/></svg> Gravar Tela`;

  // Restore toolbar and close button
  document.getElementById('videoToolbar').style.opacity = '';
  document.getElementById('videoToolbar').style.pointerEvents = '';
  document.querySelector('.modal-close').style.opacity = '';
  document.querySelector('.modal-close').style.pointerEvents = '';
  document.getElementById('videoContainer').classList.remove('recording-mode');
  document.getElementById('recordExitBtn').style.display = 'none';

  video.pause();
  savedArrowsContainer.innerHTML = '';
}

function toggleRecordPausePlay() {
  if (!screenRecordMode) return;
  if (video.paused) {
    clearTimeout(screenRecordPauseTimeout);
    video.play();
  } else {
    video.pause();
  }
}
function skipRecordPause() {
  clearTimeout(screenRecordPauseTimeout);
  if (screenRecordMode) video.play();
}

function toggleImgOpacity() {
  const imgEl = document.getElementById('modalImage');
  const btn = document.getElementById('imgOpacityBtn');
  const isFaded = !!imgEl.dataset.faded;
  imgEl.style.transition = 'filter 0.3s';
  imgEl.style.filter = isFaded ? '' : 'brightness(0.35)';
  imgEl.dataset.faded = isFaded ? '' : '1';
  btn.style.color = isFaded ? '' : 'var(--accent)';
  btn.style.borderColor = isFaded ? '' : 'var(--accent)';
  const item = mediaItems.find(m => m.id === currentMediaId);
  if (item) item.faded = !isFaded;
}

function imgNavigate(dir) {
  if (slideshowMode) return;
  const imgItems = mediaItems.filter(m => m.type === 'image');
  if (imgItems.length < 2) return;
  const curIdx = imgItems.findIndex(m => m.id === currentMediaId);
  const nextIdx = (curIdx + dir + imgItems.length) % imgItems.length;
  const nextItem = imgItems[nextIdx];
  // Cancel any pending annotation first
  imgCancelAll();
  currentMediaId = nextItem.id;
  const imgEl = document.getElementById('modalImage');
  imgEl.classList.remove('img-fade');
  void imgEl.offsetWidth;
  imgEl.classList.add('img-fade');
  imgEl.src = nextItem.url;
  // Restore opacity state for this photo
  const faded = !!nextItem.faded;
  imgEl.style.filter = faded ? 'brightness(0.35)' : ''; imgEl.dataset.faded = faded ? '1' : '';
  document.getElementById('imgOpacityBtn').style.color = faded ? 'var(--accent)' : '';
  document.getElementById('imgOpacityBtn').style.borderColor = faded ? 'var(--accent)' : '';
  annotations[currentMediaId] = annotations[currentMediaId] || [];
  renderSavedArrows();
}

// ‚îÄ‚îÄ‚îÄ IMAGE ANNOTATION FUNCTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function imgCancelAll() {
  arrowMode = false;
  textMode = false;
  activeMode = null;
  pendingTime = null;
  pendingTextContent = '';
  arrowRotation = 0;
  textRotation = 0;
  textFontSize = 10;
  textEl.style.fontSize = '15px';
  arrowEl.style.display = 'none';
  textEl.style.display = 'none';
  arrowHint.style.display = 'none';
  document.getElementById('imgArrowBtn').classList.remove('active');
  document.getElementById('imgTextBtn').classList.remove('active');
  document.getElementById('imgDoneBtn').style.display = 'none';
  document.getElementById('imgFontMinusBtn').style.display = 'none'; document.getElementById('imgFontSizeDisplay').style.display = 'none';
  document.getElementById('imgFontPlusBtn').style.display = 'none';
  { const _ib=document.getElementById('imgBgColorBtn'); if(_ib)_ib.style.display='none'; }
  document.getElementById('imgEditTextBtn').style.opacity = '0.35';
  document.getElementById('imgEditTextBtn').style.cursor = 'not-allowed';
}

function imgActivateArrow() {
  if (arrowMode) { showToast('Conclua ou desfa√ßa a seta antes de inserir outra.', 'error'); return; }
  if (textMode) { showToast('Conclua ou desfa√ßa o texto antes de inserir uma seta.', 'error'); return; }
  imgCancelAll();
  arrowMode = true;
  activeMode = 'arrow';
  pendingTime = 0;
  arrowXPct = 50; arrowYPct = 50;
  placeArrow(arrowXPct, arrowYPct);
  arrowEl.style.display = 'block';
  arrowHint.style.display = 'block';
  document.getElementById('imgArrowBtn').classList.add('active');
  document.getElementById('imgDoneBtn').style.display = 'flex';
}

function imgActivateText() {
  if (textMode) { showToast('Conclua ou desfa√ßa o texto antes de inserir outro.', 'error'); return; }
  if (arrowMode) { showToast('Conclua ou desfa√ßa a seta antes de inserir um texto.', 'error'); return; }
  imgCancelAll();
  pendingTime = 0;
  document.getElementById('textPopupInput').value = '';
  document.getElementById('textPopup').classList.add('active');
  setTimeout(() => document.getElementById('textPopupInput').focus(), 100);
}

function imgSaveCurrent() {
  if (activeMode === 'arrow') imgSaveArrow();
  else if (activeMode === 'text') imgSaveText();
}

function imgSaveArrow() {
  if (!currentMediaId) return;
  annotations[currentMediaId].push({ kind: 'arrow', time: 0, xPct: arrowXPct, yPct: arrowYPct, rotation: arrowRotation,
      _id: _newAnnId()
    });
  lastSavedAnnId = annotations[currentMediaId][annotations[currentMediaId].length - 1]._id;
  imgCancelAll();
  renderSavedArrows();
  updateBadge(currentMediaId);
}

function imgSaveText() {
  if (!pendingTextContent || !currentMediaId) return;
  const overlayRect = overlay.getBoundingClientRect();
  const customWidth = overlayRect.width > 0 ? (textEl.offsetWidth / overlayRect.width * 100) + '%' : (textEl.offsetWidth + 'px');
  const customHeight = textEl.style.height ? textEl.offsetHeight + 'px' : null;
  annotations[currentMediaId].push({
    kind: 'text',
    time: 0,
    xPct: textXPct,
    yPct: textYPct,
    text: pendingTextContent,
    rotation: textRotation,
    fontSize: textFontSize,
    customWidth: customWidth,
    customHeight: customHeight,
    bgColor: TEXT_BG_COLORS[textBgColorIdx].value,
      _id: _newAnnId()
    });
  lastSavedAnnId = annotations[currentMediaId][annotations[currentMediaId].length - 1]._id;
  imgCancelAll();
  renderSavedArrows();
  updateBadge(currentMediaId);
}

function imgUndoAnnotation() {
  if (arrowMode || textMode) {
    imgCancelAll();
    showToast('Anota√ß√£o cancelada.', '');
    return;
  }
  const anns = annotations[currentMediaId];
  if (!anns || anns.length === 0) { showToast('Nenhuma anota√ß√£o para desfazer.', 'error'); return; }
  anns.pop();
  renderSavedArrows();
  updateBadge(currentMediaId);
  showToast('‚Ü© √öltima anota√ß√£o removida.', '');
}

function imgReopenTextEdit() {
  if (!textMode) { showToast('Nenhum texto ativo para editar.', 'error'); return; }
  const input = document.getElementById('textPopupInput');
  input.value = pendingTextContent || (textEl.childNodes[0] && textEl.childNodes[0].textContent) || '';
  document.getElementById('textPopup').classList.add('active');
  setTimeout(() => input.focus(), 100);
}

function imgChangeFontSize(delta) {
  textFontSize = Math.max(4, Math.min(48, textFontSize + delta));
  textEl.style.fontSize = textFontSize + 'px';
  const disp = document.getElementById('imgFontSizeDisplay');
  if (disp) disp.textContent = textFontSize + 'px';
}

function imgRenderSaved() {
  renderSavedArrows(); // shared renderer, isImageMode controls behavior
}

// ‚îÄ‚îÄ‚îÄ SLIDESHOW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startSlideshow() {
  if (slideshowMode) { stopSlideshow(); return; }
  const imgItems = mediaItems.filter(m => m.type === 'image');
  if (imgItems.length === 0) { showToast('Nenhuma imagem para slideshow.', 'error'); return; }

  slideshowMode = true;
  let idx = imgItems.findIndex(m => m.id === currentMediaId);
  if (idx < 0) idx = 0;

  // Hide UI for clean view
  document.getElementById('imageToolbar').style.opacity = '0';
  document.getElementById('imageToolbar').style.pointerEvents = 'none';
  document.querySelector('.modal-close').style.opacity = '0';
  document.querySelector('.modal-close').style.pointerEvents = 'none';
  document.getElementById('slideshowExitBtn').style.display = 'block';

  function showNext() {
    if (!slideshowMode) return;
    const item = imgItems[idx % imgItems.length];
    currentMediaId = item.id;
    const imgEl = document.getElementById('modalImage');
    imgEl.classList.remove('img-fade');
    void imgEl.offsetWidth; // reflow
    imgEl.classList.add('img-fade');
    imgEl.src = item.url;
    renderSavedArrows();
    idx++;
    slideshowTimer = setTimeout(showNext, 2500);
  }

  showNext();
}

function stopSlideshow() {
  slideshowMode = false;
  clearTimeout(slideshowTimer);
  slideshowTimer = null;
  document.getElementById('imageToolbar').style.opacity = '';
  document.getElementById('imageToolbar').style.pointerEvents = '';
  document.querySelector('.modal-close').style.opacity = '';
  document.querySelector('.modal-close').style.pointerEvents = '';
  document.getElementById('slideshowExitBtn').style.display = 'none';
}

function showToast(msg, type = '', duration = 3000) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.className = 'toast ' + type;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), duration);
}

// ‚îÄ‚îÄ‚îÄ UTILS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function formatTime(secs) {
  const h = Math.floor(secs / 3600);
  const m = Math.floor((secs % 3600) / 60);
  const s = Math.floor(secs % 60);
  return [h,m,s].map(n => String(n).padStart(2,'0')).join(':');
}

// Close modal on Escape
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') closeModal();
});

function copyCurrentFileName() {
  const item = mediaItems.find(m => m.id === currentMediaId);
  if (!item) return;
  navigator.clipboard.writeText(item.name).then(() => {
    showToast('‚úì Nome copiado: ' + item.name, 'success');
  }).catch(() => {
    // Fallback para dispositivos sem clipboard API
    const ta = document.createElement('textarea');
    ta.value = item.name;
    ta.style.position = 'fixed';
    ta.style.opacity = '0';
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    showToast('‚úì Nome copiado: ' + item.name, 'success');
  });
}

// ‚îÄ‚îÄ‚îÄ SUBCARD IMAGE IN POPUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _subcardPendingImg = null; // dataUrl da imagem selecionada no popup

function triggerSubcardImg() {
  document.getElementById('subcardImgInput').click();
}

document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('subcardImgInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      _subcardPendingImg = ev.target.result;
      const preview = document.getElementById('subcardImgPreview');
      const previewEl = document.getElementById('subcardImgPreviewEl');
      previewEl.src = _subcardPendingImg;
      preview.style.display = 'block';
    };
    reader.readAsDataURL(file);
    this.value = '';
  });
});

function clearSubcardImg() {
  _subcardPendingImg = null;
  document.getElementById('subcardImgPreview').style.display = 'none';
  document.getElementById('subcardImgPreviewEl').src = '';
}

function showSubcardImgBtn(show) {
  const btn = document.getElementById('subcardImgBtn');
  if (btn) btn.style.display = show ? 'flex' : 'none';
  // Limpar imagem pendente ao abrir/fechar
  if (!show) clearSubcardImg();
}
</script>
<div class="text-popup" id="textPopup">
  <div class="text-popup-box">
    <h3>‚úèÔ∏è Digite o texto da anota√ß√£o</h3>
    <textarea id="textPopupInput" placeholder="Ex: Corrigir postura aqui..."></textarea>
    <!-- Pr√©via da imagem selecionada para subcard -->
    <div id="subcardImgPreview" style="display:none;margin-top:8px;text-align:center;">
      <img id="subcardImgPreviewEl" style="max-width:100%;max-height:120px;border-radius:6px;border:2px solid #e8ff47;">
      <button onclick="clearSubcardImg()" style="display:block;margin:4px auto 0;background:transparent;border:none;color:#ef4444;font-size:12px;cursor:pointer;">‚úï Remover imagem</button>
    </div>
    <div class="text-popup-actions">
      <button class="text-popup-cancel" onclick="cancelTextMode()">Cancelar</button>
      <button id="subcardImgBtn" onclick="triggerSubcardImg()" style="display:none;background:rgba(232,255,71,0.15);border:1px solid #e8ff47;color:#e8ff47;border-radius:8px;padding:11px 16px;font-family:'Syne',sans-serif;font-weight:700;font-size:13px;cursor:pointer;">üì∑</button>
      <button class="text-popup-confirm" onclick="confirmTextInput()">Confirmar ‚Üí</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

</body>
</html>
